<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Switching From Python 2 to Python 3</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/truthful.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/github.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

      <!-- 1 minute -->
      <section>

        <section data-background="#ffffff" data-background-transition="zoom" data-transition="zoom" data-transition-speed="fast">
          <h1>Switching From <nobr>Python 2</nobr> to <nobr>Python 3</nobr></h1>
          <p>
          <small><a href="http://treyhunner.com" rel="author">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <aside class="notes" data-markdown>
            TODO
          </aside>
        </section>

        <section>
          <div class="aboutme-card">
            <a href="http://truthful.technology"><img src="truthful-technology-logo.svg" class="no-style aboutme-logos"></a>
            <span>On-site training for Python/Django</span>
          </div>
          <div class="aboutme-card">
            <a href="http://weeklypython.chat"><img src="pythonchat-logo.png" class="no-style aboutme-logos"></a>
            <span>Weekly Python Chat live webcast host</span>
          </div>
          <div class="aboutme-card">
            <a href="http://pythonmorsels.com"><img src="morsels-logo.svg" class="no-style aboutme-logos"></a>
            <span>Python Morsels</span>
          </div>
          <div class="aboutme-card">
            <a href="http://pythonsd.org"><img src="pythonsd-logo.svg" class="no-style aboutme-logos"></a>
            <span>San Diego Python meetup co-organizer</span>
          </div>
          <div class="aboutme-card">
            <a href="http://djangogirls.org/sandiego"><img src="djangogirls-logo.svg" class="no-style aboutme-logos"></a>
            <span>Django Girls San Diego co-organizer</span>
          </div>
          <div class="aboutme-card">
            <a href="https://www.python.org/psf-landing/"><img src="psf-logo.png" class="no-style"></a>
            <span>Python Software Foundation director</span>
          </div>
          <aside class="notes" data-markdown>
            - My name is Trey.  I help Python &amp; Django teams on-board new teammates and turn their front-end developers into full-stack Django developers.
            - I also host a free live webcast every week on Python-related topics, usually Saturdays at 9am Pacific Time
            - And I run a Python exercise subscription service where I take the most valuable exercises from my trainings and send 1 out every week.  It's called Python Morsels.
            - I'm also one of the co-organizers of my local Python meetup in San Diego
            - I've helped organize four Django Girls workshops in Southern California
            - And I'm also one of the 11 directors at the Python Software Foundation
            - That's a bit about me... now let's talk about looping
          </aside>
        </section>

      </section>

        <!-- 1 minute -->
        <section>
          <h2>Why Upgrade to Python 3?</h2>
          <ul>
            <li>Python 2 is quirkier than Python 3 (#pythonoddity)</li>
            <li>Python 3 fixed 20 years of Python 2 bugs-turned-features</li>
            <li>Python 2 will no longer be supported on January 1, 2020</li>
            <li class="fragment"><strong>Python 2 will no longer be supported on January 1, 2020</strong></li>
            <li class="fragment"><strong>Python 2 will no longer be supported on January 1, 2020</strong></li>
            <li class="fragment"><strong>Python 2 will no longer be supported on January 1, 2020</strong></li>
          </ul>
          <aside class="notes" data-markdown>
            - This talk is *not* about *why* you should switch to Python 3
            - So I'm going to just skip over this slide
            - Because if you don't yet have a reason to upgrade to Python 3, **(click)** I'm sure you can find one **(click)**
            - **(click)**
            - **[2 minutes]**
          </aside>
        </section>

      <!-- TODO 5 minutes? -->
      <section>

        <section>
          <p><blockquote cite="https://youtu.be/Oiw23yfqQy8?t=17m5s">&ldquo;What we intentionally didn't do, but what I still regret, is we said there will be no way at runtime to combine Python 2 code and Python 3 code in the same interpreter.&rdquo; <nobr>&mdash; Guido van Rossum</nobr>, PyCascades 2018</blockquote></p>
          <aside class="notes" data-markdown>
            - There is no way to take Python 2 code and Python 3 code and run them in the same process.
            - At any time your code will run either in Python 2 or in Python 3
            - This creates a major difficulty... **(click)** because...
          </aside>
        </section>

        <section>
          <h1>Python 3 is backwards incompatible with Python 2</h1>
          <h3 class="fragment">I hope this isn't surprising</h3>
          <aside class="notes" data-markdown>
            - Python 3 is backwards incompatible with Python 2 **(click)**
            - This means that you can't just take your Python 2 code and run it in Python 3
            - If this *is* a surprise to anyone in this room... I'm sorry you had to hear this from me
            - This fact is the reason that upgrading is going to be a challenge
            - **(pause)** Because of this...
          </aside>
        </section>

        <section>
          <h2>Approaches to Upgrading</h2>
          <ul>
            <li class="fragment">Gradual: add support for 3, drop 2 eventually</li>
            <li class="fragment">Sudden: upgrade code to 3 and drop 2 immediately</li>
            <li class="fragment">Extreme: rewrite the entire code base in Python 3</li>
          </ul>
          <aside class="notes" data-markdown>
            - We're going to need to choose between a few different approaches to upgrading our code
              - **(click)** The gradual approach is to add support for Python 3 and then eventually drop Python 2 support at some point in the future.  This means writing code in such a way that it can run in *both* Python 2 and Python 3 at the same time.
              - **(click)** The sudden approach to upgrading involves upgrading your entire codebase to Python 3 at once without worrying about supporting Python 2 at the same time.  This requires dropping Python 2 support during your upgrade process.
              - **(click)** The extreme approach to upgrading is to rewrite your entire codebase in Python 3.  If you have a really small codebase, this isn't necessary the worst idea.  We're not going to talk about that approach at all though.
          </aside>
        </section>

        <section>
          <h2>Gradual or Sudden Upgrading?</h2>
          <blockquote class="fragment" cite="https://youtu.be/Oiw23yfqQy8?t=19m15s">&ldquo;Originally we thought that the intersection of Python 2 and Python 3 would be unusable.  It turns out it's not so bad.&rdquo; <nobr>&mdash; Guido van Rossum</nobr>, PyCascades 2018</blockquote>
          <aside class="notes" data-markdown>
            - So we need to decide whether we're taking the sudden approach or the gradual approach to migrating our code
            - **(click)** At PyCascades this year Guido said that the Python core developers originally thought that the intersection of Python 2 and 3 would be pretty much unusable.
            - That is definitely not the case today.
          </aside>
        </section>

        <section>
          <h2>Migrating: it used to be even harder</h2>
          <ul>
            <li class="fragment">Writing code that ran the same way in both Python 2 and Python 3 was nearly impossible</li>
            <li class="fragment">Now it's "not so bad" to write code that runs in both in both Python 2 and Python 3</li>
            <li class="fragment">We have tools to help us upgrade our code to work in both Python 2 and Python 3</li>
          </ul>
          <aside class="notes" data-markdown>
            - **(click)** It used to be pretty much impossible to write one set of code that would run in both Python 2 and Python 3.
            - **(click)** But in recent versions of Python 3, the core developers made it much easier to write code that would run the same way in both languages
            - **(click)** And now we even have some pretty decent automated tools to help do that
            - So back to our approach...
          </aside>
        </section>

        <section>
          <h2>Gradual upgrades are easiest</h2>
          <ul>
            <li class="fragment">Sudden upgrades used to be the only way</li>
            <li class="fragment">Sudden upgrades can be really tricky</li>
            <li class="fragment">I recommend gradual upgrades</li>
          </ul>
          <aside class="notes" data-markdown>
            - **(click)** The Python community used to recommend sudden upgrades because early versions of Python 3 were so incompatible with Python 2, that you couldn't even really upgrade gradually
            - **(click)** But sudden upgrades can cause a lot of bugs in your code and they can sometimes put your development cycle on pause for a really long time
            - **(click)** So while sudden upgrades used to be recommended, gradual upgrades are usually more often recommended today
            - And gradual upgrades are also what I recommend
          </aside>
        </section>

        <section>
          <h2>We're going to upgrade gradually</h2>
          <aside class="notes" data-markdown>
            - So during this talk we're going to be focusing on upgrading our code to Python 3 gradually
            - We'll gradually add support for Python 3 and then later drop Python 2 support
            - **[7 minutes]**
          </aside>
        </section>

      </section>

      <!-- TODO 6 minutes? -->
      <section>

        <section>
          <h2>Before we migrate we need to</h2>
          <ol>
            <li class="fragment">Have a very good testing process in place</li>
            <li class="fragment">Drop support for older versions (move to Python 2.7)</li>
            <li class="fragment">Start learning the differences between Python 2 and 3</li>
          </ol>
          <aside class="notes" data-markdown>
            - Before we can upgrade, we need to make sure we're prepared
            - This first step is the hardest one, but you might have already done it.
            - Before upgrading, you need to have a solid test process for your code
            - Whether manual or automated, your test process needs to be **repeatable** and **thorough**
            - That's the hardest step
            - Next you need to make sure that you only support recent versions of Python.
            - It's hard to support older versions of Python 2 at the same time as Python 3.  The newer the version of Python 2 that you're on, the easier things get
            - And lastly you'll want to start learning about the differences between 2 and 3 as you upgrade
            - During this process you'll be diving deep into Python 2 and 3 compatibility land.  It's best to start learning the basics now.
          </aside>
        </section>

        <section>
          <h2>What's our strategy?</h2>
          <ol>
            <li class="fragment">Use tools to upgrade your code to work in Python 3</li>
            <li class="fragment">Manually fix problems that can't be fixed automatically</li>
            <li class="fragment">Make sure your tests pass</li>
            <li class="fragment">Start running your code in Python 3 in production</li>
            <li class="fragment">Drop Python 2 support (if you haven't already)</li>
          </ol>
          <aside class="notes" data-markdown>
            - As far as actually upgrading, here's the high-level steps you'll take
            - You're going to want to use some tools to help you
              - You'll probably use a compatibility library that your new code will depend on
              - And also an automated code conversion tool that will remove a lot of the tediousness of upgrading
            - Unfortunately none of the automated tools can fix everything for you
            - So you're going to need to fix some things manually
            - After you make sure your code still works Python 2, you'll need to make sure it also works in Python 3
            - And then you can slowly make the switch to using Python 3 exclusively
            - **(pause)**
            - These are the high level steps.  We can get a lot more specific than this.
          </aside>
        </section>

        <section data-background="#ffffff" data-background-image="gummy-snake.jpg" data-background-size="cover" data-background-repeat="no-repeat" data-background-position="center" data-state="no-controls" class="no-controls">
          <aside class="notes" data-markdown>
            - Let's say you're at the PyLadies auction at PyCon 2015 and you're trying to split up 34,000 calorie gummy Python to distribute pieces of it to a room full of Python developers
            - What's the best way to slice a giant gummy snake?
            - There's not really one answer to this question.  There's lots of ways to slice a giant gummy snake.
            - There are also lots ways to do an upgrade from Python 2 to Python 3
          </aside>
        </section>

        <section>
          <h2>Which way will you slice this?</h2>
          <ul>
            <li class="fragment">Upgrade in stages (update then port)?</li>
            <li class="fragment">Don't upgrade in stages?</li>
            <li class="fragment">Upgrade file-by-file?</li>
            <li class="fragment">Upgrade feature-by-feature?</li>
            <li class="fragment">Use automated tools for everything, rely on your tests?</li>
            <li class="fragment">Handle buggy things like unicode/bytes manually?</li>
          </ul>
          <aside class="notes" data-markdown>
            - Surprisingly, if you ask the Internet for answers you'll get a bunch of different opinions on the right way to solve your problem
            - On the Internet you might hear people say...
            - **(click)** That you should upgrade in 2 stages (first modernize your modernize your Python 2 code, then later get it working in Python 3)
            - **(click)** You might also hear people say that stages are a bad idea
            - **(click)** Some people say to upgrade file-by-file
            - **(click)** Other people say it's better to focus on upgrading feature-by-feature
            - **(click)** People also argue over how much you should rely on the automated tools
            - **(click)** Some parts of your migration will need to fixed manually regardless of whether you decide to use a tool to help you
            - You're going to need to need to figure out for yourself which ways you're going to slice *your* migration
          </aside>
        </section>

        <section>
          <h2>Achieving Python 2/3 compatibility</h2>
          <ol>
            <li class="fragment">Write "straddling code" in the "common subset" of 2/3</li>
            <li class="fragment">Opt-in to back-ported features</li>
            <li class="fragment">Remove uses of deprecated libraries and syntax</li>
            <li class="fragment">Use a compatibility library to help us write Python 2/3 compatible code</li>
            <li class="fragment">Fix bugs that arise (unicode vs bytes)</li>
          </ol>
          <aside class="notes" data-markdown>
            - So there's not just one good answer
            - But broadly speaking this is how you'll upgrade:
            - **(click)** If you want to upgrade gradually, you're going to need to write your code in such a way that it will run in both Python 2 and Python 3.
            - To do this you'll need to mostly stick to features that fall within a "common subset" 2 and 3.
            - **(click)** There are some feature flags you can use to make Python 2 acts more like Python 3.
            - There are also a number of back-ported Python 3 features in Python 2's standard library
            - **(click)** You'll probably going to need to *stop* using syntax and features that only exist in Python 2
            - **(click)** You can a compatibility library help you bridge the gap between 2 and 3
            - **(click)** Python 3 requires you to be a lot more explicit about some things.  For example you have to careful to separate text and binary data whereas Python 2 allowed you to be a little more sloppy when it comes to working with data.
            - So even after all of this, you're still going to have to manually fix some things.
            - **[13 minutes]**
          </aside>
        </section>

      </section>

      <!-- TODO 3 minutes -->
      <section>

        <section>
          <h2>Opt-in to back-ported features</h2>
          <ul>
            <li class="fragment">Use <code>__future__</code> imports to make Python 2 act more like Python 3</li>
            <li class="fragment">Use the Python 3 versions of common Python 2 libraries</li>
          </ul>
          <aside class="notes" data-markdown>
            - A big part of getting your Python 2 code working in Python 3 is opting in to the Python 3 features that are already exist in Python 2 and you just weren't using yet
            - **(click)** You can use dunder future imports to help you out
            - dunder stands for double-underscore, as in double underscore future double underscore
            - These dunder future imports are basically feature flags that change Python 2 so that it acts a little more like Python 3
            - **(click)** You're also going to need to stop using deprecated parts of the Python 2 standard library and start using the new Python 3 versions of libraries instead
          </aside>
        </section>

        <section>
          <h2><code>__future__</code></h2>
           <pre class="python"><code data-trim data-noescape>
<span class="fragment" data-fragment-index="1"># Python 2 code
print "The answer to 5/2 is ", 5/2.0, u"\u203C"</span>

<span class="fragment" data-fragment-index="3"># Python 3 feature flags enabled in Python 2
from __future__ import print_function
from __future__ import unicode_literals
from __future__ import division</span>

<span class="fragment" data-fragment-index="2"># Python 3 code
print("The answer to 5/2 is ", 5/2, "\u203C")</span>
          </code></pre>
         <aside class="notes" data-markdown>
            - A big part of getting your Python 2 code working in Python 3 is opting in to the Python 3 features that are already exist in Python 2 and you just weren't using yet
            - **(click)** This is Python 2 code
            - **(click)** This is the same code written using Python 3 features
            - **(click)** This bottom code actually work in Python 2 also, but if we enable the Python 3-specific features that we're here
            - These dunder future imports force us to use the Python 3 print function, turn all our string literals into unicode strings, and make our division use true divison instead of truncating division
          </aside>
        </section>

        <section>
           <pre class="python fragment" data-fragment-index="1"><code data-trim data-noescape>
import csv
from <span class="fragment highlight-blue" data-fragment-index="3">urllib2 import urlopen</span>
<span class="fragment highlight-blue" data-fragment-index="3">from StringIO import StringIO</span>

def save_tabbed_data_as_csv(url, filename):
    response = <span class="fragment highlight-blue" data-fragment-index="3">StringIO</span>(urlopen(url).read())
    reader = csv.reader(response, delimiter='\t')
    csv.writer(open(filename, <span class="fragment highlight-blue" data-fragment-index="3">mode='wb'</span>)).writerows(reader)
          </code></pre>
           <pre class="python fragment" data-fragment-index="2"><code data-trim data-noescape>
import csv
<span class="fragment highlight-red" data-fragment-index="4">from <span class="fragment highlight-current-blue" data-fragment-index="3">urllib.request</span> import urlopen</span>
<span class="fragment highlight-blue" data-fragment-index="3">from io import BytesIO</span>

def save_tabbed_data_as_csv(url, filename):
    response = <span class="fragment highlight-blue" data-fragment-index="3">BytesIO</span>(urlopen(url).read())
    reader = csv.reader(response, delimiter='\t')
    csv.writer(open(filename, <span class="fragment highlight-blue" data-fragment-index="3">newline=''</span>)).writerows(reader)
          </code></pre>
         <aside class="notes" data-markdown>
           - Embracing backported libraries is also a big part of upgrading
           - **(click)** This is Python 2 code
           - **(click)** This is the same thing in Python 3
           - **(click)** Notice that there are a lot of minor differences between these two snippets of code
           - Now most of the things in that Python 3 are available in Python 2
           - **(click)** But not all of them
           - So to handle those libraries and features that are fundamentally different between Python 2 and Python 3...
            - **[16 minutes]**
          </aside>
        </section>

      </section>

      <!-- TODO 4 minutes -->
      <section>

        <section>
          <h2>Compatibility libraries</h2>
          <pre class="python fragment" data-fragment-index="3"><code data-trim>
from urllib2 import urlopen         # Python 2
from urllib.request import urlopen  # Python 3
          </code></pre>
          <h4 class="fragment" data-fragment-index="1">six</h4>
          <pre class="python fragment" data-fragment-index="4"><code data-trim>
from six.moves.urllib.request import urlopen
          </code></pre>
          <h4 class="fragment" data-fragment-index="2">future</h4>
          <pre class="python fragment" data-fragment-index="5"><code data-trim>
from future.moves.urllib.request import urlopen
          </code></pre>
          <aside class="notes" data-markdown>
            - You'll want to use a compatibility library
            - There are two compatibility libraries I'm going to talk about
            - **(click)** Six is a minimalistic library that makes many of the hard differences between Python 2 and 3 a bit easier
            - **(click)** future includes a lot more than six and it's a lot more flexible than six
            - future includes forward-ports in addition to backports as well as shims so you can start embracing Python 3 idioms more wholeheartedly within Python 2 land
            - **(click)** If we want to fix that **urllib** difference between Python 2 and Python 3 that we just saw
            - **(click)** We can do a single import this in six to make our code work in both Python 2 and Python 3
            - **(click)** Or we could do this using future instead
            - Those two import statements look almost identical
            - Despite some big similarities, six and future are far from the same library
            - Let's take a look at how six and future work differently
          </aside>
        </section>

        <section>
          <h2>Compatibility Issues</h2>
          <pre class="python fragment"><code data-trim data-noescape>
def hex_sub(hex_string):
    return <span class="fragment highlight-current-blue">unichr</span>(int(hex_string[1:], 16))
          </code></pre>
          <pre class="python fragment"><code data-trim data-noescape>
def hex_sub(hex_string):
    return <span class="fragment highlight-current-blue">chr</span>(int(hex_string[1:], 16))
          </code></pre>
          <aside class="notes" data-markdown>
            - We'll start with a difference between Python 2 and Python 3
            - **(click)** If you want to convert an integer to a unicode character in Python 2, you could use a function spelled **(click)** **unichr**
            - **(click)** If you wanted to do the same thing in Python 3, you have to use the **(click)** **chr** function instead
            - **(click)** The `chr` function existed in Python 2 but it did something different
          </aside>
        </section>

        <section>
          <h4 class="fragment" data-fragment-index="1">six</h4>
          <pre class="python fragment" data-fragment-index="1"><code data-trim>
from six import unichr

def hex_sub(hex_string):
    return unichr(int(hex_string[1:], 16))
          </code></pre>
          <h4 class="fragment" data-fragment-index="3">future</h4>
          <pre class="python fragment" data-fragment-index="3"><code data-trim data-noescape>
<span class="fragment fade-out" data-fragment-index="5">from builtins import chr</span>

def hex_sub(hex_string):
    return chr(int(hex_string[1:], 16))
          </code></pre>
          <aside class="notes" data-markdown>
            - If you want to support both Python 2 and 3 we can use either six or future
            - With `six` we we'll continue using the old `unichr` function from Python 2 **(click)**
            - But with future we can start embracing the Python 3 way of doing things **(click)**
            - Python 3 has a `builtins` module which means this code runs in Python 3 even if `future` isn't installed
            - And it runs in Python 2 because `future` includes a backport of the `builtins` that come bundled with Python 3
            - When we eventually drop support for Python 2, we don't have to change this code
            - **(click)** But we could remove that `builtins` import import if we want to clean it one day
          </aside>
        </section>

        <section>
          <h2>future is flexible</h2>
          <pre class="python fragment"><code data-trim>
from builtins import chr

def hex_sub(hex_string):
    return chr(int(hex_string[1:], 16))
          </code></pre>
          <pre class="python fragment"><code data-trim>
from past.builtins import unichr

def hex_sub(hex_string):
    return unichr(int(hex_string[1:], 16))
          </code></pre>
          <aside class="notes" data-markdown>
            - The `future` library is really flexible though
            - **(click)** We can do things the new Python 3 way
            - **(click)** But if we'd prefer to continue doing things the Python 2 first way, we can import the old Python 2 builtins instead **(click)**
            - In the `future` library, the old builtins are forward-ported and the new builtins are back-ported
          </aside>
        </section>

        <section>
          <h2>Standard library shims</h2>
          <pre class="python fragment" data-fragment-index="1"><code data-trim>
from urllib2 import urlopen         # Python 2
from urllib.request import urlopen  # Python 3
          </code></pre>
          <pre class="python fragment" data-fragment-index="2"><code data-trim>
from future.moves.urllib.request import urlopen
          </code></pre>
          <pre class="no-highlight fragment" data-fragment-index="3"><code class="hljs" data-trim data-noescape>
<span class="fragment highlight-red" data-fragment-index="4">from future.standard_library import install_aliases
install_aliases()</span>
from urllib.request import urlopen
          </code></pre>
          <aside class="notes" data-markdown>
            - One more thing about future
            - You'll want to use a compatibility library
            - **(click)** When we talked about that **urllib** difference between Python 2 and Python 3...
            - **(click)** I showed you how to solve the problem using future
            - **(click)** You can also use `future` to shim in aliases to Python 3 features into the Python 2 standard library instead
            - This is *really* cool because this means when we drop Python 2 support...
            - **(click)** We can just delete those aliases
            - **[20 minutes]**
          </aside>
        </section>

      </section>

      <!-- TODO 2 minutes -->
      <section>

        <section>
          <h2>Using automated conversion tools</h2>
          <ul>
            <li class="fragment"><span class="fragment strike"><code>2to3</code> is for sudden upgrades (support 3, drop 2)</span></li>
            <li class="fragment"><code>modernize</code> transforms code to a common 2/3 subset</li>
            <li class="fragment"><code>future</code> is like modernize but it uses Python 3 shims</li>
          </ul>
          <aside class="notes" data-markdown>
            - So far we've been talking about manually changing our code to work in both Python 2 and Python 3
            - This is a painful and tedious process, but it doesn't have to be
            - There are tools that help us with a lot of the code transformations that we need to do
            - The 2to3 tool is built-in to Python and it tries to upgrade your Python 2 code to Python 3.  It drops support for Python 2 in the process... **(click)** so we can't use 2to3 for gradual migrations.
            - **(click)** modernize is like 2to3 but it doesn't dropping support for Python 2.
            - It relies on the six library that I mentioned earlier
            - **(click)** futurize is like modernize, but it uses the `future` library that I already mentioned
            - In fact, `futurize` is just a command-line tool that's included with `future`
          </aside>
        </section>

        <section>
          <h2>Running modernize and futurize</h2>
          <pre class="bash fragment"><code data-trim data-noescape>
$ pip install <span class="fragment highlight-blue">modernize</span>
$ <span class="fragment highlight-blue">python-modernize</span> -w my_file.py
          </code></pre>
          <pre class="bash fragment"><code data-trim data-noescape>
$ pip install <span class="fragment highlight-blue">future</span>
$ <span class="fragment highlight-blue">futurize</span> -w my_file.py
          </code></pre>
          <aside class="notes" data-markdown>
            - The syntax for using modernize and futurize is very similar, but they do have a slightly confusing name difference
            - **(click)** To use modernize, we pip install modernize **(click)**
            - And then we run python-modernize **(click)** (note the python- prefix)
            - **(click)** To use futurize, we pip install *future* **(click)**
            - And then we run futurize **(click)** (without any prefix)
            - Fortunately you're only going to end up using **one** of these tools on your code
            - Automated conversion tools are nice, but you only one
          </aside>
        </section>

        <section>
          <h2>The automated tools are pretty smart</h2>
          <ul>
            <li class="fragment">Convert <code>print</code> statements to <code>print</code> functions</li>
            <li class="fragment">Convert old exception handling syntaxes to new ones</li>
            <li class="fragment">Convert old standard library imports to common paths</li>
            <li class="fragment">Wrap calls to <code>zip()</code> and <code>range()</code> in <code>list()</code> when it's necessary and don't when it isn't</li>
          </ul>
          <aside class="notes" data-markdown>
            - The automated conversion tools are pretty good about...
            - **(click)** Turning print statements into print function calls
            - **(click)** And in general they handle a lot of syntactic changes really well
            - **(click)** Both futurize and modernize will try to automatically fix uses of deprecated and moved standard library modules
            - **(click)** And the behavior changes of map, filter, zip, and range are often handled pretty well too
            - **[22 minutes]**
          </aside>
        </section>

      </section>

      <!-- 4 minutes -->
      <section>

        <section>
          <h2>Things you'll need to fix manually</h2>
          <!--<ul>
            <li>TODO dummy LIs with same contents but are hidden?</li>
          </ul>-->
          <aside class="notes" data-markdown>
            - Unfortunately the automated conversion tools can't handle everything
            - Before I explain why, we need to talk about unicode
          </aside>
        </section>

        <section>
          <h2>The Unicode Situation</h2>
          <ul>
            <li class="fragment">Python 0.9 was released before unicode existed</li>
            <li class="fragment">Python's didn't used to separate bytes from text</li>
            <li class="fragment">In Python 3, text and bytes and very distinct</li>
            <li class="fragment">The automated tools take blind guesses about which strings should be text and which should be bytes</li>
          </ul>
          <aside class="notes" data-markdown>
            - Python 0.9 was released before unicode existed **(click)**
            - Python 1.0 was released before the internet was a big deal
            - **(click)** Python never used to make a distinction between text and bytes
            - Unicode exists to separate the meaning of text from the bytes that represent the text
            - Text-based transformations don't work on raw bytes, they work on text
            - **(click)** Python 3 (wonderfully!) distinguishes between text and bytes. Python 2 does not.
            - **(click)** If Python doesn't know what you're trying to represent, the automated tools aren't going to know either
            - You're going to need to clarify in your code where and when you want text (meaning unicode strings) or bytes (meaning byte strings)
            - Ned Batchelder has a great talk on unicode talk during which he talks about "the unicode sandwich" (explain)
            - The text versus binary data part of the official porting guide explains this idea pretty well too
          </aside>
        </section>

        <section>
          <h2>Things you'll need to fix manually</h2>
          <ul>
            <li class="fragment">Python 2's <code>StringIO</code> split into <code>io.StringIO</code> for text and <code>io.BytesIO</code> for bytes</li>
            <li class="fragment">Using <code>open()</code> built-in with text data (Python 3's open lives in <code>io.open</code> in Python 2)</li>
            <li class="fragment"><code>5/2 == 2</code> in Python 2 but <code>5/2 == 2.5</code> in Python 3</li>
            <li class="fragment">Some things don't exist in the same form (<code>cmp</code> function)</li>
          </ul>
          <aside class="notes" data-markdown>
            - So a lot of the ambiguities that the automated conversion tools can't handle are due to this new distinction between text and bytes and the fact that Python 2 was really sloppy about requiring this distinction
            - Because Python 3 requires this distinction and Python 2 doesn't, you cannot unambiguously convert any Python 2 code into Python 3 code
            - Some unicode-related issues include **(click)**
              - Determining which StringIO alternative to use... io.StringIO or io.BytesIO
              - **(click)** The open() functionality changed.  Python 2 always gives you bytes back.  Python 3 gives you either text or bytes depending on what you ask for.
            - Division between integers changed in Python 3. **(click)**
            - The automated tools fail on this one because they don't know if your variables are integers or floating point numbers.
            - **(click)** And then there's some things that just don't really exist anymore in Python 3
          </aside>
        </section>

        <section>
          <h2>Tips for manually fixing stuff</h2>
          <ul>
            <li class="fragment">Use <code>io.open</code> instead of built-in <code>open</code></li>
            <li class="fragment">Specify <code>u</code> or <code>b</code> prefix for all string literals</li>
            <li class="fragment">Convert <code>StringIO</code> to <code>io.StringIO</code> or <code>io.BytesIO</code></li>
            <li class="fragment">Using the division operator consistently</li>
            <li class="fragment">Running <code>pylint --py3k</code> will prints warnings about code that might be invalid in Python 3</li>
          </ul>
          <aside class="notes" data-markdown>
            - So you're definitely going to need to fix things manually.  Here are some things to watch out for.
            - In general you need to be explicit about the distinction between text/bytes
            - **(click)** The built-in `open` function changed in Python 3.  You can find the new version in the `io` module in both Python 2 and Python 3.
            - **(click)** You'll also want to add u and b prefixes to all your string literals to clarify whether they're unicode or bytes
            - **(click)** You'll also need to convert to either io.StringIO or io.BytesIO depending on whether you're working with text or bytes
            - **(click)** And you'll need to use the division operator consistently in both 2 and 3.
            - **(click)** The pylint tool includes a `--py3k` flag that makes it so pylint doesn't print it's usual linting errors but instead prints out warnings about constructs that are invalid in Python 3
            - **[26 minutes]**
          </aside>
        </section>

      </section>

        <!-- TODO 1 minute -->
        <section>
          <h2>Python 2 to 3 Migration Cheat Sheet</h2>
          <ol>
            <li class="fragment">Use a guide to help you (<a href="https://portingguide.readthedocs.io">The Conservative Python 3 Porting Guide</a> or <a href="https://docs.python.org/3/howto/pyporting.html">the official porting guide</a>)</li>
            <li class="fragment">Make sure you have a testing process</li>
            <li class="fragment">Use an automated conversion tool (and a compatibility library) to help you</li>
            <li class="fragment">Figure out what you need to fix</li>
          </ul>
          <aside class="notes" data-markdown>
            - TODO
            - **[27 minutes]**
          </aside>
        </section>

      <!--
      <section>

        <section>
          <h2>Wait but...</h2>
          <ul>
          </ul>
          <aside class="notes" data-markdown>
            - TODO
          </aside>
        </section>

        <section>
          <h2>What about 2to3?</h2>
          <ul>
          </ul>
          <aside class="notes" data-markdown>
            - TODO
            - There is a tool built-in to Python that allows upgrading suddenly.  It's called 2to3. **(click)**
            - The official porting guide doesn't even mention 2to3 **(click)**
						- You can find resources that recommend 2to3, but most of them are older predate some of the tools that I'm going to be talking about. **(click)**
          </aside>
        </section>

        <section>
          <h2>future: is it a bad idea?</h2>
          <ul>
          </ul>
          <aside class="notes" data-markdown>
            - TODO is shimming code dangerous? (research this)
          </aside>
        </section>

      </section>
      -->

      <!-- TODO 3 minutes -->
      <section>

        <section>
          <h2>We're not done yet</h2>
          <ul>
            <li class="fragment">Upgrading opens up so many new doors for you to open</li>
            <li class="fragment">Many features in Python 3 can be used in Python 2 already, but there are lots that cannot</li>
            <li class="fragment">Python 3 exclusive looks much nicer than "straddling code" that works in both 2 and 3.  I promise.</li>
            <li class="fragment">Python 3: brought to you by the makers of Python 2</li>
          </ul>
          <aside class="notes" data-markdown>
            - Upgrading to code that runs in Python 3 could be the end of your Python 3 porting journey **(click)**
            - But it could also be just the beginning **(click)**
            - There's about a decade's worth of Python 3-only features that you've been missing out on up to now. **(click)**
            - After you've upgraded, your code in going to look pretty ugly because it was meant to run in both Python 2 and Python 3 **(click)**
            - Once you've started removing the parts of your code that only exist for Python 2 compatibility and start embracing newer Python 3 features, you'll probably find that you actually *really* enjoy using Python 3.
          </aside>
        </section>

        <section>
          <h2>Big Python 3 syntax wins</h2>
          <ul>
            <li class="fragment">Type annotations!</li>
            <li class="fragment">The way more powerful <code>*</code> and <code>**</code> syntaxes</li>
            <li class="fragment">F-Strings!</li>
            <li class="fragment">Underscores in numeric literals: <code>1_000_000</code></li>
            <li class="fragment"><code>yield from</code> and <code>async</code> and <code>await</code></li>
            <li class="fragment">Dictionary key order is preserved</li>
            <li class="fragment">Lots more cool things in the standard library</li>
          </ul>
          <aside class="notes" data-markdown>
              - Python 3 not allows you to add type hints to your code. **(click)**  These are great for documentation and they're great for making sure your code is correct!
              - **(click)** You can more easily merge dictionaries merge dictionaries, you can unpack multiple dictionaries of `**kwargs` to functions, and all sorts of cool things with the packing and unpacking generalizations
              - You can also use the `*` for writing keyword-only arguments, which is super awkward in Python 2
              - **(click)** F-strings are like the format method in Python 2 except they're way less verbose
              - **(click)** You can use underscore in numeric literals as a thousands separator
              - **(click)** Lots of standard library things like functools.total_ordering and UserDict actually work
              - **(click)** Generators got some great syntactic additions.  There's yield from.  And the async and await syntax.
              - **(click)** Python 3.7 preserves the order of dictionaries, keyword arguments, and class attributes.  This is a really cool feature change.
          </aside>
        </section>

        <section>
          <h2>Changed Python 3 "Features"</h2>
          <ul>
            <li class="fragment">True division instead of floor division</li>
            <li class="fragment">The flexible print function</li>
            <li class="fragment">Strict ordering (strings cannot be compared to numbers)</li>
          </ul>
          <aside class="notes" data-markdown>
              - Sometimes it's hard to tell a bug from a feature
              - Python 3 removed or changed a lot of features to make them look less like bugs
              - Python 3 uses true division instead of floor division **(click)**
              - Python 3 doesn't have a print statement.  Instead there's a print function which is much more flexible. **(click)**
              - And Python 3 requires strict ordering of objects. **(click)**
              - In Python 2, loose ordering was a bug waiting to happen.
            - **[30 minutes]**
          </aside>
        </section>

      </section>

      <section style="text-align: left;" data-background="#663399" data-background-transition="slide" data-transition="slide">
        <h2>Need help getting your team <nobr>up to speed on Python?</nobr></h2>
        <h3>
          <strong>Trey Hunner</strong><br>
          <small>Python &amp; Django Team Trainer</small>
        </h3>
        <p>
          <small>
            Contact me: <a href="mailto:&#116;&#114;&#101;&#121;&#064;&#116;&#114;&#117;&#116;&#104;&#102;&#117;&#108;&#046;&#116;&#101;&#099;&#104;&#110;&#111;&#108;&#111;&#103;&#121;">&#116;&#114;&#101;&#121;&#064;&#116;&#114;&#117;&#116;&#104;&#102;&#117;&#108;&#046;&#116;&#101;&#099;&#104;&#110;&#111;&#108;&#111;&#103;&#121;</a>
          </small>
        </p>
        <p>
        <a href="http://truthful.technology"><img src="logo.svg" class="no-style logo"></a>
        <a href="http://pythonmorsels.com"><img src="python-morsels-logo.svg" class="no-style logo"></a>
        </p>
        <aside class="notes" data-markdown>
          - My name is Trey Hunner
          - I would love to teach Python and Django at your company
          - Feel free to shoot me an email
          - Thank you!
        </aside>
      </section>


      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script src="js/truthful.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>
