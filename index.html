<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Switching From Python 2 to Python 3</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/truthful.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/github.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

      <!-- 1 minute -->
      <section>

        <section data-background="#ffffff" data-background-transition="zoom" data-transition="zoom" data-transition-speed="fast">
          <h1>Switching From <nobr>Python 2</nobr> to <nobr>Python 3</nobr></h1>
          <p>
          <small><a href="http://treyhunner.com" rel="author">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <aside class="notes" data-markdown>
            TODO
          </aside>
        </section>

        <section>
          <div class="aboutme-card">
            <a href="http://truthful.technology"><img src="truthful-technology-logo.svg" class="no-style aboutme-logos"></a>
            <span>On-site training for <nobr>Python &amp; Django</nobr> teams</span>
          </div>
          <div class="aboutme-card">
            <a href="http://weeklypython.chat"><img src="pythonchat-logo.png" class="no-style aboutme-logos"></a>
            <span>Weekly Python Chat live webcast host</span>
          </div>
          <div class="aboutme-card">
            <a href="http://pythonmorsels.com"><img src="morsels-logo.svg" class="no-style aboutme-logos"></a>
            <span>Python Morsels</span>
          </div>
          <div class="aboutme-card">
            <a href="http://pythonsd.org"><img src="pythonsd-logo.svg" class="no-style aboutme-logos"></a>
            <span>San Diego Python meetup co-organizer</span>
          </div>
          <div class="aboutme-card">
            <a href="http://djangogirls.org/sandiego"><img src="djangogirls-logo.svg" class="no-style aboutme-logos"></a>
            <span>Previous Django Girls <nobr>San Diego</nobr> co-organizer</span>
          </div>
          <div class="aboutme-card">
            <a href="https://www.python.org/psf-landing/"><img src="psf-logo.png" class="no-style"></a>
            <span>Python Software Foundation director</span>
          </div>
          <aside class="notes" data-markdown>
            - My name is Trey.  I help Python &amp; Django teams on-board new teammates and turn their front-end developers into full-stack Django developers.
            - I also host a free live webcast every week on Python-related topics, usually Saturdays at 9am Pacific Time
            - And I run a Python exercise subscription service where I take the most valuable exercises from my trainings and send 1 out every week.  It's called Python Morsels.
            - I'm also one of the co-organizers of my local Python meetup in San Diego
            - I've helped organize four Django Girls workshops in Southern California
            - And I'm also one of the 11 directors at the Python Software Foundation
            - That's a bit about me... now let's talk about looping
          </aside>
        </section>

      </section>

        <!-- 1 minute -->
        <section>
          <span class="fragment strike" data-fragment-index=3>
          <h1>Python 2 <span class="fragment" data-fragment-index=1>End of Life</span></h1>
          <h2 class="fragment" data-fragment-index=2>1 year, 7 months, and 20 days</h2>
          </span>
          <aside class="notes" data-markdown>
            - If you don't think you have a reason to upgrade to Python 3 **(click)**, you can probably find one
            - There's lots of good reasons to upgrade **(click)**
            - We're going to focus on the exciting reasons to upgrade in this talk **(click)**
            - So let's look at what you've been missing out on by not using Python 3
          </aside>
        </section>

      <!-- 5 minutes -->
      <section>

        <section>
           <pre class=""><code data-trim data-noescape>
<span class="fragment">>>> many_numbers = range(1_000_000, 10_000_000)
<span class="fragment">>>> first, *middle, last = many_numbers[:10_000]</span>
<span class="fragment">>>> new_numbers = [last, *middle, first]</span>
<span class="fragment">>>> print(*middle[:4], sep=', ', end='!\n')
999001, 999002, 999003, 999004!</span>
<span class="fragment">>>> print(f"{first:,}, {last:,}, and {len(middle)} more")
999,000, 999,999, and 998 more</span>
<span class="fragment">>>> 5 / 2
2.5</span></code></pre>
          <aside class="notes" data-markdown>
            - Python 3 allows for underscores in string literals to make them easier to read
            - Also pretty much all the functions like `range` that made lists in Python 2 instead give back lazy iterables in Python 3
            - Python 3 also includes a lot more generalizations for the `*` and `**` operators
            - You can use `*` in multiple assignment now
            - Or even in a list literal
            - Also the print statement became a print function, which is much more powerful
            - And there's f-strings, which a big leap up from the other kinds of string formatting
            - But there's just lots of little things that are more sensible... like the fact that 5 divided by 2 is 2.5
          </aside>
        </section>

        <section>
           <pre class="python"><code data-trim data-noescape>
from collections import UserDict
from functools import total_ordering

@total_ordering
class ComparableDict(UserDict):
    def __lt__(self, other):
        if isinstance(other, ComparableDict):
            return sorted(self) < sorted(other)
        return NotImplemented
</code></pre>
          <aside class="notes" data-markdown>
            - TODO
            - Python 2 had a UserDict, but it was an old style class so it wasn't actually usable
            - Python 2 also has a back-ported version of the `total_ordering` decorator for making objects comparable, but it's implemented in such a way that it works in Python 3 and has a bug in Python 2
          </aside>
        </section>

        <section data-transition="slide-in none-out">
           <pre class="python"><code data-trim data-noescape>
class LatLong:
    def __init__(self, lat, long):
        self.lat, self.long = lat, long
    def __eq__(self, other):
        if isinstance(other, LatLong):
            return (self.lat, self.long) == (other.lat, other.long)
        return NotImplemented
    def __ne__(self, other):
        return not self.__eq__(other)
    def __repr__(self):
        return "{class_name}(lat={lat}, long={long})".format(
            class_name=type(self),
            lat=self.lat,
            long=self.long,
        )
          </code></pre>
          <pre class="python fragment" data-fragment-index=1><code data-trim data-noescape>
>>> location = LatLong(32.5395, -117.0440)
>>> <span class="fragment" data-fragment-index=2>location
LatLong(lat=32.5395, long=-117.0440)
>>> </span><span class="fragment" data-fragment-index=3>location2 = LatLong(lat=32.5395, long=-117.0440)
>>> location == location2
True</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - This is a class in Python 2
            - It has latitude and longitude attributes **(click)**
            - And it has a nice string representation **(click)**
            - It can even be compared nicely **(click)** to similar objects **(click)**
            - In Python 3, this is even simpler though
            - That dunder ne method isn't necessary
          </aside>
        </section>

        <section data-transition="none-in none-out" data-transition-speed="default-in fast-out">
           <pre class="python"><code data-trim data-noescape>
class LatLong:
    def __init__(self, lat, long):
        self.lat, self.long = lat, long
    def __eq__(self, other):
        if isinstance(other, LatLong):
            return (self.lat, self.long) == (other.lat, other.long)
        return NotImplemented


    def __repr__(self):
        return "{class_name}(lat={lat}, long={long})".format(
            class_name=type(self),
            lat=self.lat,
            long=self.long,
        )
         </code></pre>
          <pre class="python"><code data-trim data-noescape>
>>> location = LatLong(32.5395, -117.0440)
>>> location
LatLong(lat=32.5395, long=-117.0440)
>>> location2 = LatLong(lat=32.5395, long=-117.0440)
>>> location == location2
True
          </code></pre>
          <aside class="notes" data-markdown>
            - Because inequality is implemented as the opposite of equality by default in Python 3
            - The string representation in that dunder repr method can also be cleaned up in Python 3
          </aside>
        </section>

        <section data-transition="fade-in" data-transition-speed="fast-in default-out">
           <pre class="python"><code data-noescape>class LatLong:
    def __init__(self, lat, long):
        self.lat, self.long = lat, long
    def __eq__(self, other):
        if isinstance(other, LatLong):
            return (self.lat, self.long) == (other.lat, other.long)
        return NotImplemented


    def __repr__(self):
        return f"{type(self)}(lat={self.lat}, long={self.long})"



          </code></pre>
          <pre class="python fragment fade-out"><code data-trim data-noescape>
>>> location = LatLong(32.5395, -117.0440)
>>> location
LatLong(lat=32.5395, long=-117.0440)
>>> location2 = LatLong(lat=32.5395, long=-117.0440)
>>> location == location2
True
          </code></pre>
          <aside class="notes" data-markdown>
            - Using an f-string
            - Which makes our code a lot more succinct
            - **(click)** But this is going to get even easier in Python 3.7
            - With dataclasses
          </aside>
        </section>

        <section data-transition="fade-in" data-transition-speed="default-in fast-out">
           <pre class="python"><code data-noescape>class LatLong:
    def __init__(self, lat, long):
        self.lat, self.long = lat, long
    def __eq__(self, other):
        if isinstance(other, LatLong):
            return (self.lat, self.long) == (other.lat, other.long)
        return NotImplemented


    def __repr__(self):
        return f"{type(self)}(lat={self.lat}, long={self.long})"



          </code></pre>
          <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass
class LatLong:
    lat: float
    long: float
</code></pre>
          <aside class="notes" data-markdown>
            - Dataclasses implement sane defaults for initializers, string representations, and comparison operators
          </aside>
        </section>


        <section>
           <pre class="python"><code data-trim data-noescape>
<span class="fragment" data-fragment-index=1>>>> from urllib import urlopen</span>
<span class="fragment" data-fragment-index=3>>>> list(urlopen('http://pseudorandom.name').read())
['B', 'o', ' ', 'A', 'n', '\n']</span>
<span class="fragment" data-fragment-index=9>>>> round(2.5)
3</span>
          </code></pre>
           <pre class="python"><code data-trim data-noescape>
<span class="fragment" data-fragment-index=2>>>> from urllib.request import urlopen</span>
<span class="fragment" data-fragment-index=4>>>> list(urlopen('http://pseudorandom.name').read())
[66, 111, 32, 65, 110, 10]</span>
<span class="fragment" data-fragment-index=10>>>> round(2.5)
2</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - You will find some things that are an inconvenience when switching though
            - For example lots of things in the standard library shuffled around or were removed completely **(click)**
            - The original `urllib` and `urllib2` modules were removed and then replaced **(click)**
            - Some of the basic data types changed quite a bit too **(click)**
            - If you loop over a byte string in Python 2, you get a string for each byte
            - If you loop over a byte string in Python 3, you get an integer for each byte
            - And you'll sometimes encounter changes that are so interesting they seem like bugs at first **(click)**
            - For example the `round` function works differently in Python 3 **(click)**
            - There is a good reason behind this, but it's confusing until you understand it
          </aside>
        </section>

        <section>
          <h1>Python 3</h1>
          <h2 class="fragment">Brought to you by the makers of Python 2</h2>
          <aside class="notes" data-markdown>
            - Overall, Python 3 is pretty similar to Python 2, **(click)** but a lot better
            - There's about a decade's worth of Python 3-only features that you've been missing out on up to now
          </aside>
        </section>

      </section>

      <!-- 2 minutes -->
      <section>

        <section>
          <h2>Approaches to Upgrading</h2>
          <ul>
            <li class="fragment">Gradual: add support for 3, drop 2 eventually</li>
            <li class="fragment">Sudden: upgrade code to 3 and drop 2 immediately</li>
            <li class="fragment">Extreme: rewrite the entire code base in Python 3</li>
          </ul>
          <aside class="notes" data-markdown>
            - We're going to need to choose between a few different approaches to upgrading our code
              - **(click)** The gradual approach is to add support for Python 3 and then eventually drop Python 2 support at some point in the future.  This means writing code in such a way that it can run in *both* Python 2 and Python 3 at the same time.
              - **(click)** The sudden approach to upgrading involves upgrading your entire codebase to Python 3 at once without worrying about supporting Python 2 at the same time.  This requires dropping Python 2 support during your upgrade process.
              - **(click)** The extreme approach to upgrading is to rewrite your entire codebase in Python 3.  If you have a really small codebase, this isn't necessary the worst idea.  We're not going to talk about that approach at all though.
          </aside>
        </section>

        <section>
          <h2>Sudden vs Gradual</h2>
          <ul>
            <li class="fragment">Sudden migrations are great for stagnant projects</li>
            <li class="fragment">Gradual migrations are best if you need to keep shipping</li>
            <li class="fragment">We'll discuss gradual upgrades first</li>
          </ul>
          <aside class="notes" data-markdown>
            - If you migrate all your code to Python 3 at once, you could put your development cycle on pause for a really long time
            - **(click)** that's fine if you can stop shipping new code for a few weeks as you upgrade
            - If your code base doesn't change anymore, sudden migrations are pretty great
            - **(click)** But if you *do* need to keep shipping code, I'd recommend a gradual migration process
            - Migrating gradually allows you to slowly migrate pieces of your code over time, without losing a big chunk of time all at once
            - So I'm going to talk first about migrating to Python 3 gradually
            - We'll gradually *add* support for Python 3 and then only *later* drop support for Python 2
          </aside>
        </section>

      </section>

      <!-- 3 minutes -->
      <section>

        <section>
          <h2>Gradual Migration Strategy</h2>
          <aside class="notes" data-markdown>
            - Let's do a quick high level overview of the strategy we'll use for gradually migrating our code from Python 2 to Python 3
            - There are *lots* of steps to migrating gradually
          </aside>
        </section>

        <!-- TODO you can find the steps I'm about to show you documented in a few different porting guides... this talk is not a substitute for following a porting process... you're going to need to do research after you walk out of this room -->

        <section>
          <h2>Gradual Migration Strategy</h2>
          <ol>
            <li class="fragment" data-fragment-index=1>Have a very good testing process in place</li>
            <li class="fragment" data-fragment-index=2>Drop support for older versions (move to Python 2.7)</li>
            <li class="fragment" data-fragment-index=2><span class="fragment bold-current" data-fragment-index=4>Write "straddling code" in the "common subset" of 2/3</span></li>
            <li class="fragment" data-fragment-index=2><span class="fragment bold-current" data-fragment-index=4>Opt-in to back-ported Python 3 features</span></li>
            <li class="fragment" data-fragment-index=2><span class="fragment bold-current" data-fragment-index=4>Remove uses of deprecated libraries and syntax</span></li>
            <li class="fragment" data-fragment-index=2>Rely on your tests to get your code working again</li>
            <li class="fragment" data-fragment-index=3>Start running your code on Python 3 in production</li>
            <li class="fragment" data-fragment-index=3>Drop Python 2 compatibility code and clean up your code</li>
          </ol>
          <aside class="notes" data-markdown>
            - This first step is definitely the hardest one **(click)**
            - You have to have a thorough and repeatable testing process, whether automated or manual
            - Who doesn't have a great testing process?  Actually let me put that another way... who has a colleague *(wink)* who doesn't have a good testing process yet?
            - That is the first thing you're going to need to work
            - After that... comes all the *big* scary migration steps **(click)**
            - This is where we gradually add Python 3 support to our Python 2 code, while we make sure that our code still functions in Python 2 during the whole process
            - And then after that, we can make sure our code works on Python 3 and start running it production **(click)**
            - Eventually we'll clean up our code because this process will involve a lot of temporary compatibility code
            - Outside creating your testing process, the bulk of this work will happen **(click)** in these three steps
            - These are the parts of this process that people think of as painful and scary
            - The reason people consider these steps painful and scary is because...
          </aside>
        </section>

        <section>
           <pre class="python fragment" data-fragment-index="1"><code data-trim data-noescape>
from urllib2 import urlopen

response = urlopen('http://pseudorandom.name')
name = response.read().rstrip()
print " ".join(name)
          </code></pre>
           <pre class="python fragment" data-fragment-index="2"><code data-trim data-noescape>
from __future__ import print_function
try:
    from urllib.request import urlopen
except ImportError:
    from urllib2 import urlopen

response = urlopen('http://pseudorandom.name')
name = response.read().decode('utf-8').rstrip()
print(" ".join(name))
          </code></pre>
         <aside class="notes" data-markdown>
           - It involves taking code that looks like this **(click)**
           - And refactoring it to look like this **(click)**
           - This top code only works in Python 2, but it's pretty elegant
           - This bottom code works in Python 2 *and* it works in Python 3
           - But it is *not* elegant and it's not pretty
          </aside>
        </section>

      </section>

        <!--
        <section>
           <pre class="python fragment" data-fragment-index="1"><code data-trim data-noescape>
import csv
from <span class="fragment highlight-blue" data-fragment-index="3">urllib2 import urlopen</span>
<span class="fragment highlight-blue" data-fragment-index="3">from StringIO import StringIO</span>

def save_tabbed_data_as_csv(url, filename):
    response = <span class="fragment highlight-blue" data-fragment-index="3">StringIO</span>(urlopen(url).read())
    reader = csv.reader(response, delimiter='\t')
    csv.writer(open(filename, <span class="fragment highlight-blue" data-fragment-index="3">mode='wb'</span>)).writerows(reader)
          </code></pre>
           <pre class="python fragment" data-fragment-index="2"><code data-trim data-noescape>
import csv
<span class="fragment highlight-red" data-fragment-index="4">from <span class="fragment highlight-current-blue" data-fragment-index="3">urllib.request</span> import urlopen</span>
<span class="fragment highlight-blue" data-fragment-index="3">from io import BytesIO</span>

def save_tabbed_data_as_csv(url, filename):
    response = <span class="fragment highlight-blue" data-fragment-index="3">BytesIO</span>(urlopen(url).read())
    reader = csv.reader(response, delimiter='\t')
    csv.writer(open(filename, <span class="fragment highlight-blue" data-fragment-index="3">newline=''</span>)).writerows(reader)
          </code></pre>
         <aside class="notes" data-markdown>
           - TODO
           - Embracing backported libraries is also a big part of upgrading
           - **(click)** This is Python 2 code
           - **(click)** This is the same thing in Python 3
           - **(click)** Notice that there are a lot of minor differences between these two snippets of code
           - Now most of the things in that Python 3 are available in Python 2
           - **(click)** But not all of them are
           - These minor differences cause a lot of headaches they happen over and over in your code
            - **[16 minutes]**
          </aside>
        </section>
        -->

      <!-- 1 minute -->
      <section data-transition="fade-out">

        <section data-background="#000" data-state="no-controls" class="no-controls">
          <h1>Migrating isn't easy</h1>
          <h2 class="fragment">But there is help</h2>
          <aside class="notes" data-markdown>
            - So migrating from 2 to 3 can require jumping through a lot of hoops
            - But there are tools that can help with this process
          </aside>
        </section>

        <section data-background="#000" data-background-image="dangerous-to-go-alone.png" data-background-size="cover" data-background-repeat="no-repeat" data-background-position="center" data-state="no-controls" class="no-controls" data-transition="fade-out">
          <p style="height: 6em;"></p>
          <div class="container">
            <div class="col">
              <h4 class="fragment" data-fragment-index=1><strong>Compatibility Libraries</strong></h4>
              <h4 class="fragment" data-fragment-index=3>six</h4>
              <h4 class="fragment" data-fragment-index=4><span class="fragment bold" data-fragment-index=7>future</span></h4>
            </div>
            <div class="col">
              <h4 class="fragment" data-fragment-index=2><strong>Automated Conversion</strong></h4>
              <h4 class="fragment" data-fragment-index=5>modernize</h4>
              <h4 class="fragment" data-fragment-index=6><span class="fragment bold" data-fragment-index=8>futurize</span></h4>
            </div>
          </div>
          <aside class="notes" data-markdown>
            - The tools to help us migrate are *split* into 2 categories
              - **(click)** compatibility libraries
              - **(click)** and automated code conversion tools
            - The compatibility libraries are
              - **(click)** six
              - **(click)** and future
            - The automated code conversion tools are
              - **(click)** modernize
              - **(click)** and futurize
            - I'm going to compare these tools *very* briefly but the ones I personally recommend using are **(click)** future and futurize **(click)**
          </aside>
        </section>

      </section>

      <!-- 2 minutes -->
      <section>

        <section>
          <h2>Compatibility libraries</h2>
          <aside class="notes" data-markdown>
            - Let's talk why we should use compatibility libraries
          </aside>
        </section>

        <section data-transition="fade-out">
          <pre class="no-highlight fragment" data-fragment-index=1><code class="hljs" data-trim data-noescape>
try:
    <span class="fragment highlight-current-blue" data-fragment-index=5>from urllib.request import urlopen</span>  <span class="hljs-comment"># Python 3</span>
except ImportError:
    from urllib2 import urlopen         <span class="hljs-comment"># Python 2</span>
          </code></pre>
          <pre class="fragment no-highlight" data-fragment-index=2><code class="hljs" data-trim data-noescape>
from six.moves.urllib.request import urlopen  <span class="hljs-comment"># six</span>
          </code></pre>
          <pre class="fragment no-highlight" data-fragment-index=3><code class="hljs" data-trim data-noescape>
from future.moves.urllib.request import urlopen  <span class="hljs-comment"># future</span>
          </code></pre>
          <pre class="fragment no-highlight" data-fragment-index=4><code class="hljs" data-trim data-noescape>
<span class="fragment strike" data-fragment-index=6>from future.standard_library import install_aliases
install_aliases()</span>
<span class="fragment highlight-current-blue" data-fragment-index=5>from urllib.request import urlopen</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - If you *don't* use a compatibility library, you will write a *lot* of code that looks like this **(click)**
            - Getting code working in both Python 2 and Python 3 involves a if statements and exception handling
            - With the *six* library, we can write a single import statement **(click)**
            - Or we can do a very similar import statement with *future* **(click)**
            - These compatibility libraries do a lot of the ugly version checking work behind the scenes for us
            - The reason I recommend *future* in particular is that it *can* be used the same way as six, or it can go a step further
            - And monkey patch the Python 2 standard library to work pretty much like the Python 3 standard library
            - This allows us to use the Python 3 version of urllib while we're *still in Python 2*
            - This is *really* cool because this means when we drop Python 2 support...
            - **(click)** We can just delete the lines that say `install_aliases`
            - And our code continues to work the way it should in Python 3
          </aside>
        </section>

        <section>
          <h3>The future library encourages Python 3 idioms</h3>
          <aside class="notes" data-markdown>
            - So I recommend the future library because it encourages you to embrace Python 3 during this migration process... and that's going to make cleaning up your code a *lot* easier after you're done
          </aside>
        </section>

        <!--
        <section>
          <h2>Compatibility Issues</h2>
          <pre class="python"><code data-trim data-noescape>
def hex_sub(hex_string):
    return <span class="fragment highlight-current-blue">unichr</span>(int(hex_string[1:], 16))
          </code></pre>
          <pre class="python"><code data-trim data-noescape>
def hex_sub(hex_string):
    return <span class="fragment highlight-current-blue">chr</span>(int(hex_string[1:], 16))<span class="fragment"></span>
          </code></pre>
          <aside class="notes" data-markdown>
            - We need to start with a difference between Python 2 and Python 3 first
            - If you want to convert an integer to a unicode character in Python 2, you could use a function spelled **(click)** **unichr**
            - If you wanted to do the same thing in Python 3, you have to use the **(click)** **chr** function instead
            - **(click)** The `chr` function *did* exist in Python 2 but it did something different
          </aside>
        </section>

        <section>
          <h4 class="fragment" data-fragment-index="1">six</h4>
          <pre class="python fragment" data-fragment-index="1"><code data-trim>
from six import unichr

def hex_sub(hex_string):
    return unichr(int(hex_string[1:], 16))
          </code></pre>
          <h4 class="fragment" data-fragment-index="3">future</h4>
          <pre class="python fragment" data-fragment-index="3"><code data-trim data-noescape>
<span class="fragment fade-out" data-fragment-index="5">from builtins import chr</span>

def hex_sub(hex_string):
    return chr(int(hex_string[1:], 16))
          </code></pre>
          <aside class="notes" data-markdown>
            - If you want to support both Python 2 and 3 we can use either six or future
            - With `six` we'll continue using the name `unichr` just like we did in Python 2 **(click)**
            - But with future we can start embracing the Python 3 way of doing things **(click)**
            - Python 3 has a `builtins` module which means this code runs in Python 3 even if `future` isn't installed
            - And it runs in Python 2 because `future` includes a backport of the `builtins` module that comes bundled with Python 3
            - When we eventually drop support for Python 2, we don't *have* to change this code
            - **(click)** But we could decide to remove that `builtins` import import to clean it up one day
          </aside>
        </section>

        <section>
          <h2>future is flexible</h2>
          <pre class="python"><code data-trim>
from builtins import chr

def hex_sub(hex_string):
    return chr(int(hex_string[1:], 16))
          </code></pre>
          <pre class="python fragment"><code data-trim>
from past.builtins import unichr

def hex_sub(hex_string):
    return unichr(int(hex_string[1:], 16))
          </code></pre>
          <aside class="notes" data-markdown>
            - One thing I want to mention here for completeness is that `future` includes both back-ported functionality, like that `chr` function in `builtins`
            - **(click)** And forward-ported functionality
            - Here we're importing from `past.builtins` to get an equivalent of the old Python 2 builtins in Python 3
            - So we can do things the new Python 3 way but if for any reason we need to continue doing things the old Python 2 way, we could
            - In the `future` library, the old builtins are forward-ported and the new builtins are back-ported
          </aside>
        </section>
        -->

      </section>

      <!-- 3 minutes -->
      <section>

        <section>
          <h2>Automated code conversion tools</h2>
          <ul>
            <li class="fragment"><span class="fragment strike"><code>2to3</code> is for sudden upgrades (support 3, drop 2)</span></li>
            <li class="fragment"><code>modernize</code> transforms code to a common 2/3 subset</li>
            <li class="fragment"><code>futurize</code> is like modernize but it uses Python 3 shims</li>
          </ul>
          <aside class="notes" data-markdown>
            - So far we've been talking about manually changing our code to work in both Python 2 and Python 3
            - This is a painful and tedious process, but it doesn't have to be
            - Automated code conversion tools exist to *help us* with the code transformations we need to do
            - The 2to3 tool is built-in to Python and it tries to upgrade your Python 2 code to Python 3.  It drops support for Python 2 in the process... **(click)** so we can't use 2to3 for gradual migrations.
            - **(click)** modernize is like 2to3 but it doesn't dropping support for Python 2.
            - It relies on the six library that I mentioned earlier
            - **(click)** futurize is like modernize, but it uses the `future` library that I already mentioned
            - In fact, `futurize` is just a command-line tool that's included with `future`
          </aside>
        </section>

        <!-- TODO Add slide showing difference between code automatically converted -->

        <!--
        <section>
          <h2>Running modernize and futurize</h2>
          <pre class="bash"><code data-trim data-noescape>
$ pip install <span class="fragment bold-current">modernize</span>
$ <span class="fragment bold-current">python-modernize</span> -w my_file.py
          </code></pre>
          <pre class="bash"><code data-trim data-noescape>
$ pip install <span class="fragment bold-current">future</span>
$ <span class="fragment bold-current">futurize</span> -w my_file.py<span class="fragment"></span>
          </code></pre>
          <aside class="notes" data-markdown>
            - The syntax for using modernize and futurize is very similar, but there is a slightly odd name difference
            - To use modernize, we pip install modernize **(click)**
            - And then we run python-modernize **(click)** (note the python- prefix)
            - To use futurize, we pip install *future* **(click)**
            - And then we run futurize **(click)** (without any prefix)
            - **(click)** Fortunately you're only going to end up using **one** of these tools on your code, so this naming difference won't matter much to you
            - Automated conversion tools are nice, but you only one
          </aside>
        </section>
        -->

        <!-- TODO show quick example here -->

        <!--
        <section>
          <h2>The automated tools are pretty smart</h2>
          <ul>
            <li class="fragment">Convert <code>print</code> statements to <code>print</code> functions</li>
            <li class="fragment">Convert old exception handling syntaxes to new ones</li>
            <li class="fragment">Convert old standard library imports to common paths</li>
            <li class="fragment">Wrap calls to <code>zip()</code> and <code>range()</code> in <code>list()</code> when it's necessary and don't when it isn't</li>
          </ul>
          <aside class="notes" data-markdown>
            - The automated conversion tools are pretty good about...
            - **(click)** Turning print statements into print function calls
            - **(click)** And in general they handle a lot of syntactic changes really well
            - **(click)** Both futurize and modernize will try to automatically fix uses of deprecated and moved standard library modules
            - **(click)** And the behavior changes of map, filter, zip, and range are often handled pretty well too
            - **[22 minutes]**
          </aside>
        </section>
        -->

      </section>

      <!-- 3 minutes -->
      <section>

        <section>
          <h2>You'll still need to fix things manually</h2>
          <aside class="notes" data-markdown>
            - Unfortunately the automated conversion tools can't handle everything
            - Before I explain why, we need to talk about unicode
          </aside>
        </section>

        <section>
          <h2>The Unicode Situation</h2>
          <ul>
            <li class="fragment">Unicode separates text from the bytes that represent it</li>
            <li class="fragment">Python 0.9 was released before unicode existed</li>
            <li class="fragment">Python 2.0 uses <code>str</code> for both bytes and text</li>
            <li class="fragment">Python 3.0 uses <code>str</code> for text and <code>bytes</code> for bytes</li>
            <li class="fragment">The automated tools try to guess (often incorrectly) which strings should be text and which should be bytes</li>
          </ul>
          <aside class="notes" data-markdown>
            - Unicode exists to separate the meaning of text from the bytes that represent the text
            - Python 2.0 didn't require users to make a distinction between text and bytes
            - **(click)** Python 3 (wonderfully!) distinguishes between text and bytes. Python 2 does not.
            - **(click)** If Python doesn't know what you're trying to represent, the automated tools aren't going to know either
            - You're going to need to clarify in your code where and when you want text (meaning unicode strings) or bytes (meaning byte strings)
            - Ned Batchelder has a great talk on unicode talk during which he talks about "the unicode sandwich" (explain)
            - The text versus binary data part of the official porting guide explains this idea pretty well too
          </aside>
        </section>

        <section>
          <h2>Examples of things you'll need to fix</h2>
          <ul>
            <li class="fragment">Convert <code>StringIO</code> to <code>io.StringIO</code> or <code>io.BytesIO</code></li>
            <li class="fragment">Use <code>io.open</code> instead of built-in <code>open</code></li>
            <li class="fragment">Specify <code>u</code> or <code>b</code> prefix for all string literals</li>
            <li class="fragment"><code>5/2 == 2</code> in Python 2 but <code>5/2 == 2.5</code> in Python 3</li>
            <li class="fragment">Some things don't exist in the same form (<code>cmp</code> function)</li>
            <!-- <li class="fragment">Running <code>pylint --py3k</code> will prints warnings about code that might be invalid in Python 3</li> -->
          </ul>
          <aside class="notes" data-markdown>
            - TODO I'm not going to talk about these things you need to fix manually because your tests will identify these problems
            - TODO the first three things in this list and others not in this list al
            - So a lot of the ambiguities that the automated conversion tools can't handle are due to this new distinction between text and bytes and the fact that Python 2 was really sloppy about requiring this distinction
            - Because Python 3 requires this distinction and Python 2 doesn't, you cannot unambiguously convert any Python 2 code into Python 3 code
            - Some unicode-related issues include **(click)**
              - Determining which StringIO alternative to use... io.StringIO or io.BytesIO
              - **(click)** The open() functionality changed.  Python 2 always gives you bytes back.  Python 3 gives you either text or bytes depending on what you ask for.
            - **(click)** You'll probably also want to add u and b prefixes to many your string literals to clarify whether they're unicode or bytes
            - There are some non-unicode issues you'll need to fix manually also...
            - For example division between integers changed in Python 3. **(click)**
            - And the automated tools fail on this because they don't know if your variables are integers or floating point numbers.
            - **(click)** And some things just don't really exist anymore in Python 3
            - TODO??? - **(click)** The pylint tool includes a `--py3k` flag that makes it so pylint doesn't print it's usual linting errors but instead prints out warnings about constructs that are invalid in Python 3
            - **[26 minutes]**

          </aside>
        </section>

      </section>

        <!-- 2 minutes -->
        <section>
          <h2>What about sudden migrations?</h2>
          <ol>
            <li class="fragment">Fork your Python 2 version and don't change it anymore</li>
            <li class="fragment">You could use <code>2to3</code> <span class="fragment">(I've never used it, good luck!)</span></li>
            <li class="fragment">You still need to manually fix all the same things (like unicode/bytes issues and division issues)</li>
            <li class="fragment">You still need a solid testing process</li>
          </ol>
          <aside class="notes" data-markdown>
            - TODO in theory, it's really not too different except that your code will be a little bit prettier immediately after this migration hopefully
            - TODO you shouldn't need a compatibility library
            - TODO but you will want to use an automated conversion tool to save you time: 2to3 is meant for this purpose
            - TODO you're still going to have to manually fix things because 2to3 isn't any better at figuring out ambiguities in your code than modernize or futurize are
            - TODO And you still definitely need a testing process for your code
          </aside>
        </section>

      <section style="text-align: left;" data-background="#663399" data-background-transition="slide" data-transition="slide">
        <h2>Need help getting your team <nobr>up to speed on Python?</nobr></h2>
        <h3>
          <strong>Trey Hunner</strong><br>
          <small>Python &amp; Django Team Trainer</small>
        </h3>
        <p>
          <small>
            Contact me: <a href="mailto:&#116;&#114;&#101;&#121;&#064;&#116;&#114;&#117;&#116;&#104;&#102;&#117;&#108;&#046;&#116;&#101;&#099;&#104;&#110;&#111;&#108;&#111;&#103;&#121;">&#116;&#114;&#101;&#121;&#064;&#116;&#114;&#117;&#116;&#104;&#102;&#117;&#108;&#046;&#116;&#101;&#099;&#104;&#110;&#111;&#108;&#111;&#103;&#121;</a>
          </small>
        </p>
        <p>
        <a href="http://truthful.technology"><img src="logo.svg" class="no-style logo"></a>
        <a href="http://pythonmorsels.com"><img src="python-morsels-logo.svg" class="no-style logo"></a>
        </p>
        <aside class="notes" data-markdown>
          - My name is Trey Hunner
          - I would love to teach Python and Django at your company
          - Feel free to shoot me an email
          - Thank you!
        </aside>
      </section>


      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script src="js/truthful.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>
