<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Switching From Python 2 to Python 3</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/truthful.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/github.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

      <!-- 1 minute -->
      <section>

        <section data-background="#ffffff" data-background-transition="zoom" data-transition="zoom" data-transition-speed="fast">
          <h1>Python 2 to 3</h1>
          <h2>How to Upgrade and <nobr>What Features to Start Using</nobr></h2>
          <p>
          <small><a href="http://treyhunner.com" rel="author">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <aside class="notes" data-markdown>
            - Hello!  Who is using Python 3 already?  Who is *excited* about upgrading to Python 3?  Who's upgrading because you have to?
            - So this is a very large and scary topic and I have enough time to barely touch the surface of most of the things we're going to discuss
            - So my **goal** is to give you a taste for what using Python 3 is like and what's like to upgrade while also nudging you in the right direction so that you can take a *deeper* look at all this when you actually upgrade
            - I'm going to gloss over *a lot* of things, so don't expect to understand everything I'm doing deeply.  This is the start of your research, not the end.
          </aside>
        </section>

        <section>
          <div class="aboutme-card">
            <a href="http://truthful.technology"><img src="truthful-technology-logo.svg" class="no-style aboutme-logos"></a>
            <span>On-site training for <nobr>Python &amp; Django</nobr> teams</span>
          </div>
          <div class="aboutme-card">
            <a href="http://weeklypython.chat"><img src="pythonchat-logo.png" class="no-style aboutme-logos"></a>
            <span>Weekly Python Chat live webcast host</span>
          </div>
          <div class="aboutme-card">
            <a href="http://pythonmorsels.com"><img src="morsels-logo.svg" class="no-style aboutme-logos"></a>
            <span>Python Morsels</span>
          </div>
          <div class="aboutme-card">
            <a href="http://pythonsd.org"><img src="pythonsd-logo.svg" class="no-style aboutme-logos"></a>
            <span>San Diego Python meetup co-organizer</span>
          </div>
          <div class="aboutme-card">
            <a href="http://djangogirls.org/sandiego"><img src="djangogirls-logo.svg" class="no-style aboutme-logos"></a>
            <span>Previous Django Girls <nobr>San Diego</nobr> co-organizer</span>
          </div>
          <div class="aboutme-card">
            <a href="https://www.python.org/psf-landing/"><img src="psf-logo.png" class="no-style"></a>
            <span>Python Software Foundation director</span>
          </div>
          <aside class="notes" data-markdown>
            - My name is Trey.  I help Python &amp; Django teams on-board new teammates and turn their front-end developers into full-stack Django developers.
            - I also host a free live webcast every week on Python-related topics, usually Saturdays at 9am Pacific Time
            - And I run a Python exercise subscription service where I take the most valuable exercises from my trainings and send 1 out every week.  It's called Python Morsels.
            - I'm also one of the co-organizers of my local Python meetup in San Diego
            - I've helped organize four Django Girls workshops in Southern California
            - And I'm also one of the 11 directors at the Python Software Foundation
            - That's a bit about me... let's talk about Python
          </aside>
        </section>

      </section>

      <section>

        <!-- 1 minute -->
        <section>
          <span class="fragment strike" data-fragment-index=6>
          <h1>Python 2 <span class="fragment" data-fragment-index=1>End of Life</span></h1>
          <h2 class="fragment" data-fragment-index=2>January 1, 2020</h2>
          <h2 class="fragment" data-fragment-index=3><span class="fragment bold" data-fragment-index=4><span class="fragment highlight-red" data-fragment-index=5>1 year, 7 months, 19 days</span></h2>
          </span>
          <aside class="notes" data-markdown>
            - Python 2 hasn't had many new features in a long time
            - Python 2 is still a *great* programming language
            - But... **(click)**
            - There are **a lot** of good reasons **(click)** to upgrade from Python 2 to Python 3
            - If you don't think you have a reason to upgrade...
            - **(click)**
            - You'll probably **(click)** find one soon...
            - *(pause)* **(click)**
            - *(continue pause)*
            - In this talk, we are *not* going to focus on the *necessary* reasons to upgrade
            - **(click)** You'll eventually find those on your own
            - We're going to focus on the exciting reasons to upgrade
            - So let's look at what you've been *missing out* on so far by **not** using Python 3
            - **[2 minutes]**
          </aside>
        </section>

      </section>

      <!-- 5 minutes -->
      <section>

        <section>
          <h2>Syntax improvements</h2>
          <pre class=""><code data-trim data-noescape>
<span class="fragment">>>> many_numbers = range(1_000_000, 10_000_000)
<span class="fragment">>>> first, *middle, last = many_numbers[:10_000]</span>
<span class="fragment">>>> new_numbers = [last, *middle, first]</span>
<span class="fragment">>>> print(*middle[:4], sep=', ', end='!\n')
1000001, 1000002, 1000003, 1000004!</span>
<span class="fragment">>>> print(f"{first:,}, {last:,}, and {len(middle)} more")
1,000,000, 1,009,999, and 9998 more</span>
<span class="fragment">>>> 5 / 2
2.5</span></code></pre>
          <aside class="notes" data-markdown>
            - Python 3 has lots of new syntax, most of which you can't even opt into in Python 2
            - In Python 3, **(click)** you can use underscores in numeric literals to make them easier to read
            - It's easy to see here that we have 1 million and 10 million
            - Python 3 also includes a lot more generalizations for the `\*` and `\*\*` operators
            - **(click)** For example you can use `\*` in multiple assignment now
            - **(click)** Or even when you're constructing a list
            - Also Python 2's print statement **(click)** turned into print function in Python 3, which is a lot more powerful and flexible than the old print statement ever was
            - Python 3 also has a new string formatting syntax **(click)**, called f-strings, that are a pretty big leap up over the old string formatting syntaxes from Python 2
            - And lots of other little things just a became a bit more sensible **(click)**
            - For example 5 divided by 2 in is 2.5 now... just like in real life
            - *(pause)*
            - Let's take a look at a chunk of Python 2 code and compare it to Python 3...
          </aside>
        </section>

        <section data-transition="slide-in none-out">
           <pre class="python"><code data-trim data-noescape>
class LatLong:
    def __init__(self, lat, long):
        self.lat, self.long = lat, long
    def __eq__(self, other):
        if isinstance(other, LatLong):
            return (self.lat, self.long) == (other.lat, other.long)
        return NotImplemented
    def __ne__(self, other):
        return not self.__eq__(other)
    def __repr__(self):
        return "{class_name}(lat={lat}, long={long})".format(
            class_name=type(self),
            lat=self.lat,
            long=self.long,
        )
          </code></pre>
          <pre class="python fragment" data-fragment-index=1><code data-trim data-noescape>
>>> location = LatLong(32.5395, -117.0440)
>>> <span class="fragment" data-fragment-index=2>location
LatLong(lat=32.5395, long=-117.0440)
>>> </span><span class="fragment" data-fragment-index=3>location2 = LatLong(lat=32.5395, long=-117.0440)
>>> </span><span class="fragment" data-fragment-index=4>location == location2
True</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - This is a class in Python 2
            - It has latitude and longitude attributes **(click)**
            - And it has a nice string representation **(click)**
            - It can even be compared **(click)** to similar objects **(click)**
            - In Python 3, this class can be even simpler though
            - That dunder ne method isn't actually necessary in Python 3 **(click)**
          </aside>
        </section>

        <section data-transition="none-in none-out" data-transition-speed="default-in fast-out">
           <pre class="python"><code data-trim data-noescape>
class LatLong:
    def __init__(self, lat, long):
        self.lat, self.long = lat, long
    def __eq__(self, other):
        if isinstance(other, LatLong):
            return (self.lat, self.long) == (other.lat, other.long)
        return NotImplemented


    def __repr__(self):
        return "{class_name}(lat={lat}, long={long})".format(
            class_name=type(self),
            lat=self.lat,
            long=self.long,
        )
         </code></pre>
          <pre class="python"><code data-trim data-noescape>
>>> location = LatLong(32.5395, -117.0440)
>>> location
LatLong(lat=32.5395, long=-117.0440)
>>> location2 = LatLong(lat=32.5395, long=-117.0440)
>>> location == location2
True
          </code></pre>
          <aside class="notes" data-markdown>
            - Because in Python 3, inequality is implemented as the opposite of equality by default
            - Another thing that could be improved in Python 3 is that dunder repr method
            - That string representation could be much more shorter with an f-string
          </aside>
        </section>

        <section data-transition="fade-in" data-transition-speed="fast-in default-out">
           <pre class="python"><code data-noescape>class LatLong:
    def __init__(self, lat, long):
        self.lat, self.long = lat, long
    def __eq__(self, other):
        if isinstance(other, LatLong):
            return (self.lat, self.long) == (other.lat, other.long)
        return NotImplemented


    def __repr__(self):
        return f"{type(self)}(lat={self.lat}, long={self.long})"



          </code></pre>
          <pre class="python fragment fade-out"><code data-trim data-noescape>
>>> location = LatLong(32.5395, -117.0440)
>>> location
LatLong(lat=32.5395, long=-117.0440)
>>> location2 = LatLong(lat=32.5395, long=-117.0440)
>>> location == location2
True
          </code></pre>
          <aside class="notes" data-markdown>
            - This is more succinct *and* more readable
            - **(click)** But this all is going to get even easier in Python 3.7
            - *(pause)*
            - With dataclasses
          </aside>
        </section>

        <section data-transition="fade-in" data-transition-speed="default-in fast-out">
           <pre class="python"><code data-noescape>class LatLong:
    def __init__(self, lat, long):
        self.lat, self.long = lat, long
    def __eq__(self, other):
        if isinstance(other, LatLong):
            return (self.lat, self.long) == (other.lat, other.long)
        return NotImplemented


    def __repr__(self):
        return f"{type(self)}(lat={self.lat}, long={self.long})"



          </code></pre>
          <pre class="python"><code data-trim data-noescape>
from dataclasses import dataclass

@dataclass
class LatLong:
    lat: float
    long: float
</code></pre>
          <aside class="notes" data-markdown>
            - Dataclasses implement sane defaults for initializers, string representations, and comparison operators
            - So all those methods we defined before are created for us automatically
            - Let's take a look at another example
          </aside>
        </section>

        <section>
           <pre class="python"><code data-trim data-noescape>
<span class="fragment">from collections import UserDict</span>
<span class="fragment">from functools import total_ordering</span>

<span class="fragment">@total_ordering
class ComparableDict(UserDict):
    """Implement less than and greater than on dictionary."""
    def __lt__(self, other):
        if isinstance(other, ComparableDict):
            return sorted(self.items()) &lt; sorted(other.items())
        return <span class="fragment bold">super()</span>.__lt__(other)
</span></code></pre>
          <aside class="notes" data-markdown>
            - Python 3 also has a lot of things that were either missing or just not very usable in Python 2
            - For example **(click)** the collections module has a class for making your own custom dictionary-like classes
            - This existed in Python 2, but it some very unfortunate design decisions meant that you couldn't actually use it
            - There's also a lot more helper functions in Python 3... **(click)**
            - this one, total_ordering, was back-ported to Python 2 but the Python 2 version has a bug that makes it painful to use
            - So writing a class like this is a lot less painful in Python 3
            - Also Python 3 has lots of little things that make everyday coding easier...
            - **(click)** like the fact that the super function doesn't need any arguments to work
            - In general... I think you'll find that if like Python 2
          </aside>
        </section>

        <section>
          <h1 class="fragment" data-fragment-index=2>Python 3</h1>
          <h2><span class="fragment" data-fragment-index=2>Brought to you by the makers of</span> Python 2</h2>
          <aside class="notes" data-markdown>
            - ...
            - You'll probably love Python 3 **(click)**
            - It's pretty much the same thing... but with even more of the good stuff
            - Python 3 is more consistent than Python 2 and feels more natural
            - It feels more like how Python *should* have been all along
            - **[7 minutes]**
          </aside>
        </section>

      </section>

      <!-- 2 minutes -->
      <section>

        <section>
          <h2>Approaches to Upgrading</h2>
          <ul>
            <li class="fragment">Gradual: add support for 3, drop 2 eventually</li>
            <li class="fragment">Sudden: upgrade code to 3 and drop 2 immediately</li>
            <li class="fragment">Extreme: rewrite the entire code base in Python 3</li>
          </ul>
          <aside class="notes" data-markdown>
            - We're going to need to choose between a few different approaches to upgrading our code
            - **(click)** The gradual approach is to add support for Python 3 and then eventually drop Python 2 support at some point in the future.  This means writing code in such a way that it can run in *both* Python 2 and Python 3 at the same time.
            - **(click)** The sudden approach to upgrading involves upgrading your entire codebase to Python 3 at once without worrying about supporting Python 2 at the same time.  This requires dropping Python 2 support during your upgrade process.
            - **(click)** The extreme approach to upgrading is to rewrite your entire codebase in Python 3.  If you have a really small codebase, this isn't necessary the worst idea.  We're not going to talk about that approach at all though.
          </aside>
        </section>

        <section>
          <h2>Sudden vs Gradual</h2>
          <ul>
            <li class="fragment">Sudden migrations are great for stagnant projects</li>
            <li class="fragment">Gradual migrations are best if you need to keep shipping</li>
            <li class="fragment">We'll discuss gradual upgrades first</li>
          </ul>
          <aside class="notes" data-markdown>
            - If you migrate all your code to Python 3 at once, you could put your development cycle on pause for a really long time
            - **(click)** that's fine if you can stop shipping new code for a few weeks as you upgrade
            - If your code base doesn't change anymore, sudden migrations are pretty great
            - **(click)** But if you *do* need to keep shipping code, I'd recommend a gradual migration process
            - Migrating gradually allows you to slowly migrate pieces of your code over time, without losing a big chunk of time all at once
            - So I'm going to focus **(click)** on migrating your code gradually so you can keep shipping code as you migrate
            - We'll gradually *add* support for Python 3 and then only *later* drop support for Python 2
            - **[9 minutes]**
          </aside>
        </section>

      </section>

      <!-- 3 minutes -->
      <section>

        <section>
          <h2>Gradual Migration Strategy</h2>
          <aside class="notes" data-markdown>
            - Let's do a quick high level overview of the strategy we'll use for gradually migrating our code from Python 2 to Python 3
            - There are *lots* of steps to migrating gradually
          </aside>
        </section>

        <section>
          <h2>Gradual Migration Strategy</h2>
          <ol>
            <li class="fragment" data-fragment-index=1>Have a very good testing process in place</li>
            <li class="fragment" data-fragment-index=2>Drop support for older versions (move to Python 2.7)</li>
            <li class="fragment" data-fragment-index=2><span class="fragment bold-current" data-fragment-index=4>Write "straddling code" in the "common subset" of 2/3</span></li>
            <li class="fragment" data-fragment-index=2><span class="fragment bold-current" data-fragment-index=4>Opt-in to back-ported Python 3 features</span></li>
            <li class="fragment" data-fragment-index=2><span class="fragment bold-current" data-fragment-index=4>Remove uses of deprecated libraries and syntax</span></li>
            <li class="fragment" data-fragment-index=2>Rely on your tests to get your code working again</li>
            <li class="fragment" data-fragment-index=3>Start running your code on Python 3 in production</li>
            <li class="fragment" data-fragment-index=3>Drop Python 2 compatibility code and clean up your code</li>
          </ol>
          <aside class="notes" data-markdown>
            - This first step is definitely the hardest one **(click)**
            - You have to have a thorough and repeatable testing process, whether automated or manual
            - Who doesn't have a great testing process?  Actually let me put that another way... who has a colleague *(wink)* who doesn't have a good testing process yet?
            - That is the first thing you're going to need to work
            - After that... comes all the *big* scary migration steps **(click)**
            - This is where we gradually add Python 3 support to our Python 2 code, while we make sure that our code still functions in Python 2 during the whole process
            - And then after that, we can make sure our code works on Python 3 and start running it production **(click)**
            - Eventually we'll clean up our code because this process will involve a lot of temporary compatibility code
            - Outside creating your testing process, the bulk of this work will happen **(click)** in these three steps
            - These are the parts of this process that people think of as painful and scary
            - The reason people consider these steps painful and scary is because...
          </aside>
        </section>

        <section>
           <pre class="python fragment" data-fragment-index="1"><code data-trim data-noescape>
from urllib2 import urlopen

response = urlopen('http://pseudorandom.name')
name = response.read().rstrip()
print " ".join(name)
          </code></pre>
           <pre class="python fragment" data-fragment-index="2"><code data-trim data-noescape>
from __future__ import print_function
try:
    from urllib.request import urlopen
except ImportError:
    from urllib2 import urlopen

response = urlopen('http://pseudorandom.name')
name = response.read().decode('utf-8').rstrip()
print(" ".join(name))
          </code></pre>
         <aside class="notes" data-markdown>
           - It involves taking code that looks like this **(click)**
           - And refactoring it to look like this **(click)**
           - This top code only works in Python 2, but it's pretty elegant
           - This bottom code works in Python 2 *and* it works in Python 3
           - But it is *not* elegant and it's not pretty
          </aside>
        </section>

      </section>

      <!-- 1 minute -->
      <section data-transition="fade-out">

        <section data-background="#000" data-state="no-controls" class="no-controls">
          <h1>Migrating isn't easy</h1>
          <h2 class="fragment">But there is help</h2>
          <aside class="notes" data-markdown>
            - So migrating from 2 to 3 can require jumping through a lot of hoops
            - But there are tools that can help with this process
          </aside>
        </section>

        <section data-background="#000" data-background-image="dangerous-to-go-alone.png" data-background-size="cover" data-background-repeat="no-repeat" data-background-position="center" data-state="no-controls" class="no-controls" data-transition="fade-out">
          <p style="height: 6em;"></p>
          <div class="container">
            <div class="col">
              <h4 class="fragment" data-fragment-index=1><strong>Compatibility Libraries</strong></h4>
              <h4 class="fragment" data-fragment-index=3>six</h4>
              <h4 class="fragment" data-fragment-index=4><span class="fragment bold" data-fragment-index=7>future</span></h4>
            </div>
            <div class="col">
              <h4 class="fragment" data-fragment-index=2><strong>Automated Conversion</strong></h4>
              <h4 class="fragment" data-fragment-index=5>modernize</h4>
              <h4 class="fragment" data-fragment-index=6><span class="fragment bold" data-fragment-index=8>futurize</span></h4>
            </div>
          </div>
          <aside class="notes" data-markdown>
            - The tools to help us migrate are *split* into 2 categories
              - **(click)** compatibility libraries
              - **(click)** and automated code conversion tools
            - The compatibility libraries are
              - **(click)** six
              - **(click)** and future
            - The automated code conversion tools are
              - **(click)** modernize
              - **(click)** and futurize
            - I'm going to compare these tools *very* briefly but the ones I personally recommend using are **(click)** future and futurize **(click)**
            - **[12 minutes]**
          </aside>
        </section>

      </section>

      <!-- 2 minutes -->
      <section>

        <section>
          <h2>Compatibility libraries</h2>
          <aside class="notes" data-markdown>
            - Let's talk why we should use compatibility libraries
          </aside>
        </section>

        <section data-transition="fade-out">
          <pre class="no-highlight fragment" data-fragment-index=1><code class="hljs" data-trim data-noescape>
try:
    <span class="fragment highlight-current-blue" data-fragment-index=5>from urllib.request import urlopen</span>  <span class="hljs-comment"># Python 3</span>
except ImportError:
    from urllib2 import urlopen         <span class="hljs-comment"># Python 2</span>
          </code></pre>
          <pre class="fragment no-highlight" data-fragment-index=2><code class="hljs" data-trim data-noescape>
from six.moves.urllib.request import urlopen  <span class="hljs-comment"># six</span>
          </code></pre>
          <pre class="fragment no-highlight" data-fragment-index=3><code class="hljs" data-trim data-noescape>
from future.moves.urllib.request import urlopen  <span class="hljs-comment"># future</span>
          </code></pre>
          <pre class="fragment no-highlight" data-fragment-index=4><code class="hljs" data-trim data-noescape>
<span class="fragment strike" data-fragment-index=6>from future.standard_library import install_aliases
install_aliases()</span>
<span class="fragment highlight-current-blue" data-fragment-index=5>from urllib.request import urlopen</span>
          </code></pre>
          <aside class="notes" data-markdown>
            - If you *don't* use a compatibility library, you will write a *lot* of code that looks like this **(click)**
            - Getting code working in both Python 2 and Python 3 involves a if statements and exception handling
            - With the *six* library, we can write a single import statement **(click)**
            - Or we can do a very similar import statement with *future* **(click)**
            - These compatibility libraries do a lot of the ugly version checking work behind the scenes for us
            - The reason I recommend *future* in particular is that it *can* be used the same way as six, or it can go a step further
            - **(click)** And monkey patch the Python 2 standard library to work pretty much like the Python 3 standard library
            - This allows us to use the Python 3 version of urllib **(click)** while we're *still in Python 2*
            - This is *really* cool because this means when we drop Python 2 support...
            - **(click)** We can just delete those first couple lines
            - And our code continues to work the way it should in Python 3
          </aside>
        </section>

        <section>
          <h3>The future library encourages Python 3 idioms</h3>
          <aside class="notes" data-markdown>
            - So I recommend the future library because it encourages you to embrace Python 3 during this migration process... and that's going to make cleaning up your code a *lot* easier after you're done
            - **[14 minutes]**
          </aside>
        </section>

      </section>

      <!-- 3 minutes -->
      <section>

        <section>
          <h2>Automated code conversion tools</h2>
          <ul>
            <li class="fragment" data-fragment-index=1>These tools transform code to a common 2/3 subset</li>
            <li class="fragment" data-fragment-index=2><code>modernize</code> relies on the <code>six</code> compatibility library</li>
            <li class="fragment" data-fragment-index=3><span class="fragment bold" data-fragment-index=6><code>futurize</code> relies on on the <code>future</code> library</span></li>
            <li class="fragment" data-fragment-index=4><span class="fragment strike" data-fragment-index=5><code>2to3</code> is for sudden upgrades (support 3, drop 2)</span></li>
          </ul>
          <aside class="notes" data-markdown>
            - Refactoring your code to work in both Python 2 and Python 3 can be tedious and time consuming
            - But there are tools out there **(click)** that can refactor our code *for* us
            - one of these tools is called **(click)** `modernize` and it relies on `six`
            - **(click)** the other tool is called `futurize` and it relies on `future`
            - In fact, `futurize` is actually just a command-line tool that comes bundled with `future`
            - There is *another* automated conversion tool... **(click)**
            - it's called 2to3 and it's actually built-in right into Python
            - 2to3 tries to upgrade your code to Python 3 while dropping support for Python 2 all at once... **(click)** so we can't use it for gradual migrations
            - I focused on the `future` library before and I'll focus on the **(click)** `futurize` conversion tool right now
          </aside>
        </section>

        <section data-transition="slide-in fade-out">
           <pre class="python"><code data-trim data-noescape>
class Circle(object):
    def __init__(self, radius=1):
        self.radius = radius

    def <span class="fragment bold">__nonzero__</span>(self):
        return self.radius != 0

for n in <span class="fragment bold">range</span>(3):
    circle = Circle(n)
    truthiness = "truthy" if circle else "falsey"
    <span class="fragment bold">print</span> "Circle with radius", circle.radius, "is", truthiness
          </code></pre>
         <aside class="notes" data-markdown>
           - This is Python 2 code
           - This code *will not* work on Python 3
           - **(click)** `\_\_nonzero\_\_` was renamed in Python 3
           - **(click)** `range` objects work differently (although that actually doesn't matter much in this case)
           - And Python 3 doesn't have a **(click)** `print` statement
           - If we run this code through futurize, it'll make this
          </aside>
        </section>

        <section data-transition="fade-in slide-out">
           <pre class="python"><code data-trim data-noescape>
<span class="fragment strike" data-fragment-index=7><span class="fragment bold-current" data-fragment-index=4>from __future__ import print_function</span>
<span class="fragment bold-current" data-fragment-index=5><span class="fragment bold-current" data-fragment-index=3>from builtins import range</span>
<span class="fragment bold-current" data-fragment-index=2>from builtins import object</span></span></span>

class Circle(<span class="fragment bold-current" data-fragment-index=2>object</span>):
    def __init__(self, radius=1):
        self.radius = radius

    def <span class="fragment bold-current" data-fragment-index=1>__bool__</span>(self):
        return self.radius != 0

for n in <span class="fragment bold-current" data-fragment-index=3>range</span>(3):
    circle = Circle(n)
    truthiness = "truthy" if circle else "falsey"
    <span class="fragment bold-current" data-fragment-index=4>print</span>("Circle with radius", circle.radius, "is", truthiness)<span class="fragment" data-fragment-index=6></span>

          </code></pre>
         <aside class="notes" data-markdown>
           - **(click)** `futurize` renamed `\_\_nonzero\_\_` to `\_\_bool\_\_`
           - which actually still works in both Python 2 because of this fancy `builtins.object` **(click)** class that includes compatibility code to make `\_\_bool\_\_` work even in Python 2
           - Also note that this **(click)** `range` object is the Python 3 version because we're importing it from `builtins` as well
           - **(click)** And the print statement was turned into a print function
           - *(pause and scroll)*
           - That `\_\_future\_\_` thing is something the core developers added to Python 2 to allow opting in to certain Python 3 features **before you even upgrade**
           - **(click)** These `builtins` imports are quite different though
           - The `future` library includes a `builtins` library *with* it to allow Python 2 code to use the **Python 3 built-ins**
           - It's called `builtins` because Python 3 already *has* a `builtins` library that's equivalent to this **(click)**
           - So when we eventually drop support for Python 2 this code will keep working in Python 3, even *after* we **stop using `future`**
           - We will of course eventually clean up this code by removing **(click)** those *unnecessary* imports statements
           - *(pause)*
           - So using an automated conversion tool can be **really** helpful...
          </aside>
        </section>

      </section>

      <!-- 3 minutes -->
      <section>

        <section>
          <h2>You'll still need to fix things manually</h2>
          <aside class="notes" data-markdown>
            - But these tools aren't flawless
            - You're still going to need to fix certain bugs manually
            - I'll explain why with an example
            - **[20 minutes]**
          </aside>
        </section>

        <section data-transition="slide-in fade-out">
           <pre class="python"><code data-noescape>

import csv
<span class="fragment bold-current">from urllib2 import urlopen</span>
<span class="fragment bold-current">from StringIO import StringIO</span><span class="fragment"></span>

def save_tabbed_data_as_csv(url, filename):
    response = StringIO(urlopen(url).read())
    reader = csv.reader(response, delimiter='\t')
    csv_file = open(filename, mode='wb')
    csv.writer(csv_file).writerows(reader)</code></pre>
         <aside class="notes" data-markdown>
           - This is Python 2 code
           - It uses two standard library modules that don't exist in Python 3
           - **(click)** `urllib2`
           - and `StringIO` **(click)**
           - *(pause)* **(click)**
           - If we run futurize on this code it'll fix these imports
          </aside>
        </section>

        <section data-transition="fade-in fade-out">
           <pre class="python"><code data-trim data-noescape>
<span class="fragment" data-fragment-index=3>from future import standard_library
standard_library.install_aliases()</span>
import csv
<span class="fragment bold-current" data-fragment-index=1>from urllib.request import urlopen</span>
<span class="fragment bold-current" data-fragment-index=2>from <span class="fragment bold-current" data-fragment-index=5>io</span> import StringIO</span>

def save_tabbed_data_as_csv(url, filename):
    response = <span class="fragment bold-current" data-fragment-index=5>StringIO</span>(<span class="fragment bold-current" data-fragment-index=4>urlopen(url).read()</span>)
    reader = <span class="fragment bold-current" data-fragment-index=6>csv.reader</span>(response, delimiter='\t')
    csv_file = open(filename, <span class="fragment bold-current" data-fragment-index=7>mode='wb'</span>)
    <span class="fragment bold-current" data-fragment-index=6><span class="fragment bold-current" data-fragment-index=8>csv.writer</span></span>(csv_file).writerows(reader)<span class="fragment bold-current" data-fragment-index=9></span>
          </code></pre>
         <aside class="notes" data-markdown>
           - So that they use the new Python 3 versions of these libraries: **(click)** `urllib.request` and **(click)** `io`
           - To get the Python 3 versions of these libraries to work in Python 2, `futurize` also **(click)** monkey patches the Python 2 standard library using `install_aliases`
           - *(pause)* This is both a step forward and a step back.  I say that because this code is actually broken now.
           - It **doesn't work** in Python 3 yet and it **doesn't even work in Python 2** anymore
           - One problem is that **(click)** `urlopen` gives us bytes back
           - But **(click)** `io.StringIO` expects unicode
           - Also the `csv` `reader` **(click)** and `writer` objects will not work with bytes in Python 3
           - But we're opening our output file **(click)** in bytes mode
           - Which the Python 3 `csv.writer` **(click)** object is **not** going to be happy about
           - So... after we've run our automated conversion tool, **(click)** we still need to fix this code manually
           - We can do... that like this...
          </aside>
        </section>

        <section data-transition="fade-in slide-out">
           <pre class="python"><code data-trim data-noescape>
from future import standard_library
standard_library.install_aliases()
import csv
from urllib.request import urlopen
from <span class="fragment bold-current" data-fragment-index=2>io</span> import StringIO, <span class="fragment bold-current" data-fragment-index=4>open</span>

def save_tabbed_data_as_csv(url, filename):
    response = <span class="fragment bold-current" data-fragment-index=2>StringIO</span>(urlopen(url).read().<span class="fragment bold-current" data-fragment-index=1>decode('utf-8')</span>)
    reader = csv.reader(response, delimiter='\t')
    csv_file = open(filename, <span class="fragment bold-current" data-fragment-index=3>mode='wt'</span>, <span class="fragment bold-current" data-fragment-index=5>newline=''</span>)
    csv.writer(csv_file).writerows(reader)<span class="fragment" data-fragment-index=6></span>
          </code></pre>
         <aside class="notes" data-markdown>
           - So we're now **(click)** **decoding** the **byte string** that we get back from urlopen
           - *So* that **(click)** `io.StringIO` will be *happy*
           - And then we're opening up our output file in **(click)** text mode
           - and using a back-ported version of the Python 3 **(click)** `open` function
           - So that we can now use the **(click)** `newline` keyword argument that didn't used to exist in Python 2
           - Which is the recommended way of handling Windows support for CSV files, **(click)** which is the whole reason we had that bytes mode writing going on in the first place
           - *(pause)* *(breathe)*
           - So unless you've used the `urllib` and `csv` modules in both Python 2 and Python 3, that was probably a little confusing
           - But what I'm *trying* to **get at**.. is that...
          </aside>
        </section>

        <section>
          <h2>The automated conversion tools won't solve all your problems</h2>
          <h3 class="fragment">You'll still need to fix code manually</h3>
          <aside class="notes" data-markdown>
            - The automated conversion tools are **not a magic wand**
            - They'll push you in the right direction
            - **(click)** but you'll still need to fix some things manually
            - There's really no *getting around* this problem
            - *(very long pause)*
            - So you may have noticed that the bugs that we just fixed manually all related to with **the same underlying issue**
            - and it's a **pretty big** issue when migrating from Python 2 to Python 3
            - The issue is... unicode
          </aside>
        </section>

        <section>
          <h2>The Unicode Situation</h2>
          <ul>
            <li class="fragment">Python 3.0 uses <code>str</code> for text and <code>bytes</code> for bytes</li>
            <li class="fragment">Python 2.0 uses <code>str</code> for both bytes and text</li>
            <li class="fragment">The automated tools try to guess (often incorrectly) which strings should be text and which should be bytes</li>
            <li class="fragment">Embrace the "unicode sandwich" from <a href="https://nedbatchelder.com/text/unipain.html">Pragmatic Unicode</a></li>
          </ul>
          <aside class="notes" data-markdown>
            - Python 3 (wonderfully!) **(click)** distinguishes between text and bytes.
            - **(click)** Python 2 does not.
            - So a lot of the ambiguities that the automated conversion tools can't handle are due to this distinction between text and bytes and the fact that Python 2 was sloppy about requiring this distinction
            - Because Python 3 requires distinguish between bytes and unicode but Python 2 doesn't, **(click)** you cannot unambiguously convert arbitrary Python 2 code into Python 3 code
            - And if the meaning of your code is ambiguous, the automated tools aren't always going to guess how to do the right thing
            - Ned Batchelder has **(click)** a great talk on unicode that I'd recommend called Pragmatic Unicode.
            - While I'm mentioning links to refer to during this process, let me mention a few more...
            - **[24 minutes]**
          </aside>
        </section>

      </section>

        <section>
          <h2>Useful Resources</h2>
          <ol>
            <li><a href="https://portingguide.readthedocs.io/en/latest/">The Conservative Python 3 Porting Guide</a></li>
            <li><a href="https://docs.python.org/3/howto/pyporting.html">Porting Python 2 Code to Python 3</a></li>
            <li><a href="http://python3porting.com/bookindex.html">Supporting Python 3: An in-depth guide</a></li>
            <li><a href="https://www.pluralsight.com/courses/python-2-to-python-3">Migrating Python 2 to Python 3</a></li>
            <li><a href="https://nedbatchelder.com/text/unipain.html">Pragmatic Unicode</a></li>
          </ol>
          <aside class="notes" data-markdown>
            - The conservative Python 3 porting guide was written by some folks at Redhat I believe and it's a guide for folks who are upgrading not *because* they want the shiny new Python 3 features but because they have to update to continue receiving support
            - The Python documentation has an official porting guide from 2 to 3.  It's targeted at third-party projects which need to support both 2 and 3, but you could use it when migrating gradually also
            - The book Supporting Python 3 is free online.  It's a little older and focuses more on sudden migrations, but it has some things in it that will be useful to consider regardless of the migration approach you take
            - Migrating Python 2 to 3 is a Pluralsight course by Anthony Shaw.  It's very new and it also focuses on future and futurize
            - And the talk Pragmatic Unicode by Ned Batchelder is something you should watch regardless of whether you upgrade
            - **[25 minutes]**
          </aside>
        </section>

        <!-- 2 minutes -->
        <section>
          <h2>What about sudden migrations?</h2>
          <ol>
            <li class="fragment">Fork your Python 2 version and don't change it anymore</li>
            <li class="fragment">You could use <code>2to3</code> <span class="fragment">(I've never used it, good luck!)</span></li>
            <li class="fragment">You still need to manually fix all the same things (like unicode/bytes issues and division issues)</li>
            <li class="fragment">You still need a solid testing process</li>
          </ol>
          <aside class="notes" data-markdown>
            - One thing I didn't talk about was sudden migrations
            - In theory, sudden migrations aren't really that different from gradual migrations
            - Because the migration is one-way, **(click)** you'll want to stop all code progress until after you're done migrating
            - You shouldn't need a compatibility library
            - But you'll still want to use an automated conversion tool: **(click)** 2to3 is meant for this purpose
            - I've never actually used it **(click)**, but a lot of other people have
            - **(click)** you're still going to have to manually fix things though because 2to3 isn't any more magical than modernize or futurize
            - **(click)** And you *definitely* still need a testing process for your code
            - Migrating to Python 3 is hard regardless of whether you're doing it suddenly or gradually
            - **[27 minutes]**
          </aside>
        </section>

        <!-- 2 minutes -->
        <section>
          <h1>Good Luck!</h1>
          <aside class="notes" data-markdown>
            - I wish you luck... and speed
          </aside>
        </section>

      <section style="text-align: left;" data-background="#663399" data-background-transition="slide" data-transition="slide">
        <h2>Need help getting your team <nobr>up to speed on Python?</nobr></h2>
        <h3>
          <strong>Trey Hunner</strong><br>
          <small>Python &amp; Django Team Trainer</small>
        </h3>
        <p>
          <small>
            Contact me: <a href="mailto:&#116;&#114;&#101;&#121;&#064;&#116;&#114;&#117;&#116;&#104;&#102;&#117;&#108;&#046;&#116;&#101;&#099;&#104;&#110;&#111;&#108;&#111;&#103;&#121;">&#116;&#114;&#101;&#121;&#064;&#116;&#114;&#117;&#116;&#104;&#102;&#117;&#108;&#046;&#116;&#101;&#099;&#104;&#110;&#111;&#108;&#111;&#103;&#121;</a>
          </small>
        </p>
        <p>
        <a href="http://truthful.technology"><img src="logo.svg" class="no-style logo"></a>
        <a href="http://pythonmorsels.com"><img src="python-morsels-logo.svg" class="no-style logo"></a>
        </p>
        <aside class="notes" data-markdown>
          - That's all I've got for you
          - Thank you
        </aside>
      </section>


      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script src="js/truthful.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>
