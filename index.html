<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Switching From Python 2 to Python 3</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/truthful.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/github.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

      <!-- 1 minute -->
      <section>

        <section data-background="#ffffff" data-background-transition="zoom" data-transition="zoom" data-transition-speed="fast">
          <h1>Switching From <nobr>Python 2</nobr> to <nobr>Python 3</nobr></h1>
          <p>
          <small><a href="http://treyhunner.com" rel="author">Trey Hunner</a> / <a href="https://twitter.com/treyhunner">@treyhunner</a></small>
          </p>
          <aside class="notes" data-markdown>
            TODO
          </aside>
        </section>

        <section>
          <div class="aboutme-card">
            <a href="http://truthful.technology"><img src="truthful-technology-logo.svg" class="no-style aboutme-logos"></a>
            <span>On-site training for <nobr>Python &amp; Django</nobr> teams</span>
          </div>
          <div class="aboutme-card">
            <a href="http://weeklypython.chat"><img src="pythonchat-logo.png" class="no-style aboutme-logos"></a>
            <span>Weekly Python Chat live webcast host</span>
          </div>
          <div class="aboutme-card">
            <a href="http://pythonmorsels.com"><img src="morsels-logo.svg" class="no-style aboutme-logos"></a>
            <span>Python Morsels</span>
          </div>
          <div class="aboutme-card">
            <a href="http://pythonsd.org"><img src="pythonsd-logo.svg" class="no-style aboutme-logos"></a>
            <span>San Diego Python meetup co-organizer</span>
          </div>
          <div class="aboutme-card">
            <a href="http://djangogirls.org/sandiego"><img src="djangogirls-logo.svg" class="no-style aboutme-logos"></a>
            <span>Previous Django Girls <nobr>San Diego</nobr> co-organizer</span>
          </div>
          <div class="aboutme-card">
            <a href="https://www.python.org/psf-landing/"><img src="psf-logo.png" class="no-style"></a>
            <span>Python Software Foundation director</span>
          </div>
          <aside class="notes" data-markdown>
            - My name is Trey.  I help Python &amp; Django teams on-board new teammates and turn their front-end developers into full-stack Django developers.
            - I also host a free live webcast every week on Python-related topics, usually Saturdays at 9am Pacific Time
            - And I run a Python exercise subscription service where I take the most valuable exercises from my trainings and send 1 out every week.  It's called Python Morsels.
            - I'm also one of the co-organizers of my local Python meetup in San Diego
            - I've helped organize four Django Girls workshops in Southern California
            - And I'm also one of the 11 directors at the Python Software Foundation
            - That's a bit about me... now let's talk about looping
          </aside>
        </section>

      </section>

        <!-- 1 minute -->
        <section>
          <h2>Why Upgrade to Python 3?</h2>
          <ul>
            <li>Python 2 is quirkier than Python 3 (#pythonoddity)</li>
            <li>Python 3 fixed 20 years of Python 2 bugs-turned-features</li>
            <li>Python 2 will no longer be supported on January 1, 2020</li>
            <li class="fragment"><strong>Python 2 will no longer be supported on January 1, 2020</strong></li>
            <li class="fragment"><strong>Python 2 will no longer be supported on January 1, 2020</strong></li>
            <li class="fragment"><strong>Python 2 will no longer be supported on January 1, 2020</strong></li>
          </ul>
          <aside class="notes" data-markdown>
            - This talk is *not* about *why* you should switch to Python 3
            - So I'm going to just skip over this slide
            - Because if you don't yet have a reason to upgrade to Python 3, **(click)** I'm sure you can find one **(click)**
            - **(click)**
            - **[2 minutes]**
          </aside>
        </section>

        <!-- 2 minutes -->
        <section>
          <h2>Differences Between 2 and 3</h2>
           <pre class="python"><code data-trim data-noescape>
<span class="fragment">>>> print "hello"  # Python 2
hello</span>
<span class="fragment">>>> print("hello")  # Python 3
hello</span>
<span class="fragment">>>> from urllib2 import urlopen  # Python 2</span>
<span class="fragment">>>> from urllib.request import urlopen  # Python 3</span>
<span class="fragment">>>> urlopen('http://pseudorandom.name').read()  # Python 2
'Judy Corona\n'</span>
<span class="fragment">>>> urlopen('http://pseudorandom.name').read()  # Python 3
b'Judy Corona\n'</span>
<span class="fragment">>>> list(b'hello')
['h', 'e', 'l', 'l', 'o']</span>
<span class="fragment">>>> list(b'hello')
[104, 101, 108, 108, 111]</span>
<span class="fragment">>>> 5 / 2  # Python 2
2</span>
<span class="fragment">>>> 5 / 2  # Python 3
2.5</span>
          </code></pre>
         <aside class="notes" data-markdown>
           - This talk is not about the differences between Python 2 and 3
           - I do want to quickly note some of the differences though
           - **(click)** Python 2 had a print statement
           - **(click)** Python 3 has a print function
           - **(click)** Python 2 had a whole bunch of different names for URL-related libraries
           - **(click)** Python 3 just has one called `urllib`
           - **(click)** Python 2's default string representation was a byte strings
           - **(click)** Python 3's strings are unicode by default.  Byte strings are for low-level operations like network requests
           - **(click)** Byte strings in Python 2 give you characters when you loop over them
           - **(click)** In Python 3, they give you numbers.  Because they're strings meant for manipulating bytes.
           - **(click)** Python 2 used floor division for integers
           - **(click)** Python 3 uses true division for all types of numbers
          </aside>
        </section>

      <!-- 3 minutes -->
      <section>

        <section>
          <p><blockquote cite="https://youtu.be/Oiw23yfqQy8?t=17m5s">&ldquo;What we intentionally didn't do, but what I still regret, is we said there will be no way at runtime to combine Python 2 code and Python 3 code in the same interpreter.&rdquo; <nobr>&mdash; Guido van Rossum</nobr>, PyCascades 2018</blockquote></p>
          <aside class="notes" data-markdown>
            - There is no way to take Python 2 code and Python 3 code and run them in the same process.
            - At any time your code will run either in Python 2 or in Python 3
            - This creates a major difficulty... **(click)** because...
          </aside>
        </section>

        <section>
          <h1>Python 3 is backwards incompatible with Python 2</h1>
          <h3 class="fragment">I hope this isn't surprising</h3>
          <aside class="notes" data-markdown>
            - Python 3 is backwards incompatible with Python 2 **(click)**
            - This means that you can't just take your Python 2 code and run it in Python 3
            - If this *is* a surprise to anyone in this room... I'm sorry you had to hear this from me
            - This fact is the reason that upgrading is going to be a challenge
            - **(pause)** Because of this...
          </aside>
        </section>

        <section>
          <h2>Approaches to Upgrading</h2>
          <ul>
            <li class="fragment">Gradual: add support for 3, drop 2 eventually</li>
            <li class="fragment">Sudden: upgrade code to 3 and drop 2 immediately</li>
            <li class="fragment">Extreme: rewrite the entire code base in Python 3</li>
          </ul>
          <aside class="notes" data-markdown>
            - We're going to need to choose between a few different approaches to upgrading our code
              - **(click)** The gradual approach is to add support for Python 3 and then eventually drop Python 2 support at some point in the future.  This means writing code in such a way that it can run in *both* Python 2 and Python 3 at the same time.
              - **(click)** The sudden approach to upgrading involves upgrading your entire codebase to Python 3 at once without worrying about supporting Python 2 at the same time.  This requires dropping Python 2 support during your upgrade process.
              - **(click)** The extreme approach to upgrading is to rewrite your entire codebase in Python 3.  If you have a really small codebase, this isn't necessary the worst idea.  We're not going to talk about that approach at all though.
          </aside>
        </section>

        <section>
          <h2>Gradual is best for active code</h2>
          <ul>
            <li class="fragment">Sudden upgrades used to be the only way</li>
            <li class="fragment">Sudden upgrades can be really tricky</li>
            <li class="fragment">I recommend gradual upgrades for non-stagnant code</li>
          </ul>
          <aside class="notes" data-markdown>
            - **(click)** The Python community used to recommend sudden upgrades because early versions of Python 3 were so incompatible with Python 2, that you couldn't even really upgrade gradually
            - **(click)** But upgrading can sometimes put your development cycle on pause for a really long time
            - **(click)** So while sudden upgrades used to be recommended, gradual upgrades are usually more often recommended today
            - And gradual upgrades are also what I recommend unless you have a code base that doesn't change anymore
          </aside>
        </section>

        <section>
          <h2>We're going to upgrade gradually</h2>
          <aside class="notes" data-markdown>
            - So during this talk we're going to be focusing on upgrading our code to Python 3 gradually
            - We'll gradually add support for Python 3 and then later drop Python 2 support
            - I'll briefly talk about sudden migrations at the end
            - **[7 minutes]**
          </aside>
        </section>

      </section>

      <!-- 5 minutes -->
      <section>

        <section>
          <h2>Our Migration Strategy</h2>
          <ol>
            <li class="fragment">Prepare for the migration</li>
            <li class="fragment">Update our code to run the same under Python 2 and 3</li>
            <li class="fragment">Switch to Python 3 everywhere</li>
          </ol>
          <aside class="notes" data-markdown>
            - Our migration strategy is going to break down to three high level parts
            - **(click)** We need to prepare both ourselves and our code for this migration process
            - **(click)** Then we're going to need to modify our code so that it runs correctly under Python 3 while still working the same way under Python 2
            - **(click)** After that we'll want to start using exclusively Python 3 everywhere and then dropping support for Python 2
            - We'll start by talking about that first step: preparing to migrate
          </aside>
        </section>

        <section>
          <h3>Preparing for the migration</h3>
          <ol>
            <li class="fragment">Have a very good testing process in place</li>
            <li class="fragment">Drop support for older versions (move to Python 2.7)</li>
            <li class="fragment"><span class="fragment bold">Start learning the differences between Python 2 and 3</span></li>
            <li style="visibility: hidden; height: 0;"><strong>Start learning the differences between Python 2 and 3</strong></li>
          </ol>
          <aside class="notes" data-markdown>
            - This first step in preparing to migrate is definitely the hardest one... but you've *may have* already done it.
            - Before upgrading, you need to have a solid test process for your code **(click)**
            - Whether manual or automated, your test process needs to be **repeatable** and **thorough**
            - That's the hardest step
            - Next you need to make sure that you only support recent versions of Python. **(click)**
            - It's hard to support older versions of Python 2 at the same time as Python 3.  The newer the version of Python 2 that you're on, the easier things get
            - And lastly you'll want to start learning about the differences between 2 and 3 as you upgrade **(click)**
            - You're going to dive deep into Python 2 and 3 compatibility land during your migration so you're going to need to understand some of the core differences.
            - During this talk I will not discuss writing automated tests and upgrading to Python 2.7
            - **(click)** But we will be looking at some of the big differences between Python 2 and Python 3
          </aside>
        </section>

        <section>
          <h3>Migrating to code that is 2/3 compatible</h3>
          <span class="fragment bold" data-frament-index=6>
          <ol>
            <li class="fragment" data-fragment-index=1>Write "straddling code" in the "common subset" of 2/3</li>
            <li class="fragment" data-fragment-index=2>Opt-in to back-ports and remove deprecated features</li>
            <li class="fragment" data-fragment-index=3>Remove uses of deprecated libraries and syntax</li>
            <li class="fragment">Rely on your tests to make sure your code works</li>
            <!--
            <li class="fragment" data-fragment-index=4>Use tools to upgrade your code to work in Python 3</li>
            <li class="fragment" data-fragment-index=5>Manually fix problems that can't be fixed automatically</li>
            -->
          </ol>
          </span>
          <aside class="notes" data-markdown>
            - The migration process itself is a bit complex
            - **(click)** We want to refactor our code so that in runs in both Python 2 and Python 3
            - This is often called "bridging code" or "straddling code"... these are all just fancy words that mean "code that works in both"
            - **(click)** There are a number of back-ported Python 3 features in Python 2 that you can opt-in to using to make your life a little easier
            - There's also some Python 2 exclusive syntax you'll need to stop using
            <!--
            - **(click)** You're going to want to use both compatibility libraries and automated code conversion tools to help you upgrade.
            - There are some pretty great tools out there to make upgrading easier, but they won't fix everything **(click)**
            - So you're going to need to manually fix some of the bugs that will be introduced to your code.  You'll rely **heavily** on your test process to do this.
            -->
            - You're going to rely **heavily** on your tests to make sure that your code continues to work in Python 2
            - Eventually you'll also also get your code working in Python 3
            - After you make sure your code still works Python 2, you'll need to make sure it also works in Python 3
            - And then you can slowly make the switch to using Python 3 exclusively

            - So there's a lot of steps here.
            - We're going to focus on... **(click)** all of them
          </aside>
        </section>

        <!--
        <section>
          <h2>Achieving Python 2/3 compatibility</h2>
          <ol>
            <li class="fragment">Write "straddling code" in the "common subset" of 2/3</li>
            <li class="fragment">Opt-in to back-ported features</li>
            <li class="fragment">Remove uses of deprecated libraries and syntax</li>
            <li class="fragment">Use a compatibility library to help us write Python 2/3 compatible code</li>
            <li class="fragment">Fix bugs that arise (unicode vs bytes)</li>
          </ol>
          <aside class="notes" data-markdown>
            - But broadly speaking this is what you care about:
            - **(click)** you're going to need to write your code in such a way that it will run in both Python 2 and Python 3
            - To do this you'll need to mostly stick to features that fall within a "common subset" 2 and 3.
            - **(click)** There are some feature flags you can use to make Python 2 acts more like Python 3.
            - There are also a number of back-ported Python 3 features in Python 2's standard library
            - **(click)** You'll probably going to need to *stop* using syntax and features that only exist in Python 2
            - **(click)** You can a compatibility library help you bridge the gap between 2 and 3
            - **(click)** Python 3 requires you to be a lot more explicit about some things.  For example you have to careful to separate text and binary data whereas Python 2 allowed you to be a little more sloppy when it comes to working with data.
            - So even after all of this, you're still going to have to manually fix some things.
            - **[13 minutes]**
          </aside>
        </section>
        -->

        <section>
          <h2>After migrating</h2>
          <ol>
            <li class="fragment">Make sure your tests pass</li>
            <li class="fragment">Start running your code in Python 3 in production</li>
            <li class="fragment">Drop Python 2 support and start embracing Python 3</li>
          </ol>
          <aside class="notes" data-markdown>
            - After your code works in both Python 2 and Python 3... **(click)**
            - your tests should passing in both
            - Once you're confident that your code actually works in Python 3... **(click)**
            - Start running your code in Python 3 in your production environment
            - Once you've been running Python 3 in production for a while, **(click)** drop support for Python 2
          </aside>
        </section>

      </section>

      <!-- 3 minutes -->
      <section>

        <section>
          <h2>Opt-in to back-ported features</h2>
          <ul>
            <li class="fragment">Use <code>__future__</code> imports to make Python 2 act more like Python 3</li>
            <li class="fragment">Use the Python 3 versions of common Python 2 libraries</li>
          </ul>
          <aside class="notes" data-markdown>
            - A big part of getting your Python 2 code working in Python 3 is opting in to the Python 3 features that are already exist in Python 2 and you just weren't using yet
            - **(click)** You can use dunder future imports to help you out
            - dunder stands for double-underscore, as in double underscore future double underscore
            - These dunder future imports are basically feature flags that change Python 2 so that it acts a little more like Python 3
            - **(click)** You're also going to need to stop using deprecated parts of the Python 2 standard library and start using the new Python 3 versions of libraries instead
          </aside>
        </section>

        <section>
          <h2><code>__future__</code></h2>
           <pre class="python"><code data-trim data-noescape>
<span class="fragment" data-fragment-index="1"># Python 2 code
print "The answer to 5/2 is ", 5/2.0, u"\u203C"</span>

<span class="fragment" data-fragment-index="3"># Python 3 feature flags enabled in Python 2
from __future__ import print_function
from __future__ import unicode_literals
from __future__ import division</span>

<span class="fragment" data-fragment-index="2"># Python 3 code
print("The answer to 5/2 is ", 5/2, "\u203C")</span>
          </code></pre>
         <aside class="notes" data-markdown>
            - A big part of getting your Python 2 code working in Python 3 is opting in to the Python 3 features that are already exist in Python 2 and you just weren't using yet
            - **(click)** This is Python 2 code
            - **(click)** This is the same code written using Python 3 features
            - **(click)** This bottom code actually work in Python 2 also, but if we enable the Python 3-specific features that we're here
            - These dunder future imports force us to use the Python 3 print function, turn all our string literals into unicode strings, and make our division use true divison instead of truncating division
          </aside>
        </section>

        <section>
           <pre class="python fragment" data-fragment-index="1"><code data-trim data-noescape>
import csv
from <span class="fragment highlight-blue" data-fragment-index="3">urllib2 import urlopen</span>
<span class="fragment highlight-blue" data-fragment-index="3">from StringIO import StringIO</span>

def save_tabbed_data_as_csv(url, filename):
    response = <span class="fragment highlight-blue" data-fragment-index="3">StringIO</span>(urlopen(url).read())
    reader = csv.reader(response, delimiter='\t')
    csv.writer(open(filename, <span class="fragment highlight-blue" data-fragment-index="3">mode='wb'</span>)).writerows(reader)
          </code></pre>
           <pre class="python fragment" data-fragment-index="2"><code data-trim data-noescape>
import csv
<span class="fragment highlight-red" data-fragment-index="4">from <span class="fragment highlight-current-blue" data-fragment-index="3">urllib.request</span> import urlopen</span>
<span class="fragment highlight-blue" data-fragment-index="3">from io import BytesIO</span>

def save_tabbed_data_as_csv(url, filename):
    response = <span class="fragment highlight-blue" data-fragment-index="3">BytesIO</span>(urlopen(url).read())
    reader = csv.reader(response, delimiter='\t')
    csv.writer(open(filename, <span class="fragment highlight-blue" data-fragment-index="3">newline=''</span>)).writerows(reader)
          </code></pre>
         <aside class="notes" data-markdown>
           - Embracing backported libraries is also a big part of upgrading
           - **(click)** This is Python 2 code
           - **(click)** This is the same thing in Python 3
           - **(click)** Notice that there are a lot of minor differences between these two snippets of code
           - Now most of the things in that Python 3 are available in Python 2
           - **(click)** But not all of them are
           - These minor differences cause a lot of headaches they happen over and over in your code
            - **[16 minutes]**
          </aside>
        </section>

      </section>

      <!-- 1 minute -->
      <section>

        <section data-background="#000" data-state="no-controls" class="no-controls" data-transition>
          <h1>Migrating isn't easy</h1>
          <h2 class="fragment">But there is help</h2>
          <aside class="notes" data-markdown>
            - So migrating from 2 to 3 can require jumping through a lot of hoops
            - But there are tools that can help with this process
          </aside>
        </section>

        <section data-background="#000" data-background-image="dangerous-to-go-alone.png" data-background-size="cover" data-background-repeat="no-repeat" data-background-position="center" data-state="no-controls" class="no-controls" data-transition-out="fade">
          <p style="height: 6em;"></p>
          <div class="container">
            <div class="col">
              <h4 class="fragment" data-fragment-index=1><strong>Compatibility Libraries</strong></h4>
              <h4 class="fragment" data-fragment-index=3>six</h4>
              <h4 class="fragment" data-fragment-index=4>future</h4>
            </div>
            <div class="col">
              <h4 class="fragment" data-fragment-index=2><strong>Automated Conversion</strong></h4>
              <h4 class="fragment" data-fragment-index=5>modernize</h4>
              <h4 class="fragment" data-fragment-index=6>futurize</h4>
            </div>
          </div>
          <aside class="notes" data-markdown>
            - I'm going to mention a number of different tools you can use to help you migrate your code to support both Python 2 and Python 3
            - The tools are split into two categories
              - **(click)** compatibility libraries
              - **(click)** and automated code conversion tools
            - The main compatibility libraries are
              - **(click)** six
              - **(click)** and future
            - The main automated code conversion tools are
              - **(click)** modernize
              - **(click)** and futurize
            - By the way the logo in the center of this slide is for the future project because none of the other projects had logos
            - Marketing: it's important!
          </aside>
        </section>

      </section>

      <!-- 5 minutes -->
      <section>

        <section>
          <h2>Compatibility libraries</h2>
          <pre class="python fragment" data-fragment-index="3"><code data-trim>
from urllib2 import urlopen         # Python 2
from urllib.request import urlopen  # Python 3
          </code></pre>
          <h4 class="fragment" data-fragment-index="1">six</h4>
          <pre class="python fragment" data-fragment-index="4"><code data-trim>
from six.moves.urllib.request import urlopen
          </code></pre>
          <h4 class="fragment" data-fragment-index="2">future</h4>
          <pre class="python fragment" data-fragment-index="5"><code data-trim>
from future.moves.urllib.request import urlopen
          </code></pre>
          <aside class="notes" data-markdown>
            - We're going to talk about the compatibility libraries first
            - **(click)** Six is a minimalistic library that makes many of the hard differences between Python 2 and 3 a bit easier
            - **(click)** future includes a lot more than six and it's also a lot more flexible than six is
            <!-- - future includes forward-ports in addition to backports as well as shims so you can start embracing Python 3 idioms more wholeheartedly within Python 2 land -->
            - **(click)** If we want to fix that **urllib** difference between Python 2 and Python 3 that we just saw
            - **(click)** We can do a single import this in six to make our code work in both Python 2 and Python 3
            - **(click)** Or we could do this using future instead
            - Those two import statements look almost identical
            - Despite some big similarities, six and future are far from the same library
            - Let's take a look at how six and future work differently
          </aside>
        </section>

        <section>
          <h2>Compatibility Issues</h2>
          <pre class="python"><code data-trim data-noescape>
def hex_sub(hex_string):
    return <span class="fragment highlight-current-blue">unichr</span>(int(hex_string[1:], 16))
          </code></pre>
          <pre class="python"><code data-trim data-noescape>
def hex_sub(hex_string):
    return <span class="fragment highlight-current-blue">chr</span>(int(hex_string[1:], 16))<span class="fragment"></span>
          </code></pre>
          <aside class="notes" data-markdown>
            - We need to start with a difference between Python 2 and Python 3 first
            - If you want to convert an integer to a unicode character in Python 2, you could use a function spelled **(click)** **unichr**
            - If you wanted to do the same thing in Python 3, you have to use the **(click)** **chr** function instead
            - **(click)** The `chr` function *did* exist in Python 2 but it did something different
          </aside>
        </section>

        <section>
          <h4 class="fragment" data-fragment-index="1">six</h4>
          <pre class="python fragment" data-fragment-index="1"><code data-trim>
from six import unichr

def hex_sub(hex_string):
    return unichr(int(hex_string[1:], 16))
          </code></pre>
          <h4 class="fragment" data-fragment-index="3">future</h4>
          <pre class="python fragment" data-fragment-index="3"><code data-trim data-noescape>
<span class="fragment fade-out" data-fragment-index="5">from builtins import chr</span>

def hex_sub(hex_string):
    return chr(int(hex_string[1:], 16))
          </code></pre>
          <aside class="notes" data-markdown>
            - If you want to support both Python 2 and 3 we can use either six or future
            - With `six` we'll continue using the name `unichr` just like we did in Python 2 **(click)**
            - But with future we can start embracing the Python 3 way of doing things **(click)**
            - Python 3 has a `builtins` module which means this code runs in Python 3 even if `future` isn't installed
            - And it runs in Python 2 because `future` includes a backport of the `builtins` module that comes bundled with Python 3
            - When we eventually drop support for Python 2, we don't *have* to change this code
            - **(click)** But we could decide to remove that `builtins` import import to clean it up one day
          </aside>
        </section>

        <section>
          <h2>future is flexible</h2>
          <pre class="python"><code data-trim>
from builtins import chr

def hex_sub(hex_string):
    return chr(int(hex_string[1:], 16))
          </code></pre>
          <pre class="python fragment"><code data-trim>
from past.builtins import unichr

def hex_sub(hex_string):
    return unichr(int(hex_string[1:], 16))
          </code></pre>
          <aside class="notes" data-markdown>
            - One thing I want to mention here for completeness is that `future` includes both back-ported functionality, like that `chr` function in `builtins`
            - **(click)** And forward-ported functionality
            - Here we're importing from `past.builtins` to get an equivalent of the old Python 2 builtins in Python 3
            - So we can do things the new Python 3 way but if for any reason we need to continue doing things the old Python 2 way, we could
            - In the `future` library, the old builtins are forward-ported and the new builtins are back-ported
          </aside>
        </section>

        <section>
          <h2>Standard library shims</h2>
          <pre class="python fragment" data-fragment-index="1"><code data-trim>
from urllib2 import urlopen         # Python 2
from urllib.request import urlopen  # Python 3
          </code></pre>
          <pre class="python fragment" data-fragment-index="2"><code data-trim>
from future.moves.urllib.request import urlopen
          </code></pre>
          <pre class="no-highlight fragment" data-fragment-index="3"><code class="hljs" data-trim data-noescape>
<span class="fragment highlight-red" data-fragment-index="4">from future.standard_library import install_aliases
install_aliases()</span>
from urllib.request import urlopen
          </code></pre>
          <aside class="notes" data-markdown>
            - But the biggest difference between `future` and `six` is that `future` contains shims for the standard library that allow Python 2 to use import schemes that normally only work in Python 3
            - **(click)** When we talked about that **urllib** difference between Python 2 and Python 3...
            - **(click)** I showed you how to solve the problem using future
            - **(click)** But you could instead use `future` take those Python 3 standard library equivalents and shim them into the Python 2 standard library
            - This is *really* cool because this means when we drop Python 2 support...
            - **(click)** We can just delete the lines that say `install_aliases`
            - And our code continues to work the way it should in Python 3
            - **[20 minutes]**
          </aside>
        </section>

      </section>

      <!-- 3 minutes -->
      <section>

        <section>
          <h2>Automated code conversion tools</h2>
          <ul>
            <li class="fragment"><span class="fragment strike"><code>2to3</code> is for sudden upgrades (support 3, drop 2)</span></li>
            <li class="fragment"><code>modernize</code> transforms code to a common 2/3 subset</li>
            <li class="fragment"><code>futurize</code> is like modernize but it uses Python 3 shims</li>
          </ul>
          <aside class="notes" data-markdown>
            - So far we've been talking about manually changing our code to work in both Python 2 and Python 3
            - This is a painful and tedious process, but it doesn't have to be
            - Automated code conversion tools exist to *help us* with the code transformations we need to do
            - The 2to3 tool is built-in to Python and it tries to upgrade your Python 2 code to Python 3.  It drops support for Python 2 in the process... **(click)** so we can't use 2to3 for gradual migrations.
            - **(click)** modernize is like 2to3 but it doesn't dropping support for Python 2.
            - It relies on the six library that I mentioned earlier
            - **(click)** futurize is like modernize, but it uses the `future` library that I already mentioned
            - In fact, `futurize` is just a command-line tool that's included with `future`
          </aside>
        </section>

        <section>
          <h2>Running modernize and futurize</h2>
          <pre class="bash"><code data-trim data-noescape>
$ pip install <span class="fragment bold-current">modernize</span>
$ <span class="fragment bold-current">python-modernize</span> -w my_file.py
          </code></pre>
          <pre class="bash"><code data-trim data-noescape>
$ pip install <span class="fragment bold-current">future</span>
$ <span class="fragment bold-current">futurize</span> -w my_file.py<span class="fragment"></span>
          </code></pre>
          <aside class="notes" data-markdown>
            - The syntax for using modernize and futurize is very similar, but there is a slightly odd name difference
            - To use modernize, we pip install modernize **(click)**
            - And then we run python-modernize **(click)** (note the python- prefix)
            - To use futurize, we pip install *future* **(click)**
            - And then we run futurize **(click)** (without any prefix)
            - **(click)** Fortunately you're only going to end up using **one** of these tools on your code, so this naming difference won't matter much to you
            - Automated conversion tools are nice, but you only one
          </aside>
        </section>

        <!-- TODO show actual examples here -->
        <section>
          <h2>The automated tools are pretty smart</h2>
          <ul>
            <li class="fragment">Convert <code>print</code> statements to <code>print</code> functions</li>
            <li class="fragment">Convert old exception handling syntaxes to new ones</li>
            <li class="fragment">Convert old standard library imports to common paths</li>
            <li class="fragment">Wrap calls to <code>zip()</code> and <code>range()</code> in <code>list()</code> when it's necessary and don't when it isn't</li>
          </ul>
          <aside class="notes" data-markdown>
            - The automated conversion tools are pretty good about...
            - **(click)** Turning print statements into print function calls
            - **(click)** And in general they handle a lot of syntactic changes really well
            - **(click)** Both futurize and modernize will try to automatically fix uses of deprecated and moved standard library modules
            - **(click)** And the behavior changes of map, filter, zip, and range are often handled pretty well too
            - **[22 minutes]**
          </aside>
        </section>

      </section>

      <!-- 4 minutes -->
      <section>

        <section>
          <h2>Things you'll need to fix manually</h2>
          <ul style="visibility: hidden;">
            <li>Python 2's <code>StringIO</code> split into <code>io.StringIO</code> for text and <code>io.BytesIO</code> for bytes</li>
            <li>Using <code>open()</code> built-in with text data (Python 3's open lives in <code>io.open</code> in Python 2)</li>
            <li><code>5/2 == 2</code> in Python 2 but <code>5/2 == 2.5</code> in Python 3</li>
            <li>Some things don't exist in the same form (<code>cmp</code> function)</li>
          </ul>
          <aside class="notes" data-markdown>
            - Unfortunately the automated conversion tools can't handle everything
            - Before I explain why, we need to talk about unicode
          </aside>
        </section>

        <section>
          <h2>The Unicode Situation</h2>
          <ul>
            <li class="fragment">Python 0.9 was released before unicode existed</li>
            <li class="fragment">Python's didn't used to separate bytes from text</li>
            <li class="fragment">In Python 3, text and bytes and very distinct</li>
            <li class="fragment">The automated tools take blind guesses about which strings should be text and which should be bytes</li>
          </ul>
          <aside class="notes" data-markdown>
            - Python 0.9 was released before unicode existed **(click)**
            - Python 1.0 was released before the internet was a big deal
            - **(click)** Python never used to make a distinction between text and bytes
            - Unicode exists to separate the meaning of text from the bytes that represent the text
            - Text-based transformations don't work on raw bytes, they work on text
            - **(click)** Python 3 (wonderfully!) distinguishes between text and bytes. Python 2 does not.
            - **(click)** If Python doesn't know what you're trying to represent, the automated tools aren't going to know either
            - You're going to need to clarify in your code where and when you want text (meaning unicode strings) or bytes (meaning byte strings)
            - Ned Batchelder has a great talk on unicode talk during which he talks about "the unicode sandwich" (explain)
            - The text versus binary data part of the official porting guide explains this idea pretty well too
          </aside>
        </section>

        <section>
          <h2>Things you'll need to fix manually</h2>
          <ul>
            <li class="fragment">Convert <code>StringIO</code> to <code>io.StringIO</code> or <code>io.BytesIO</code></li>
            <li class="fragment">Use <code>io.open</code> instead of built-in <code>open</code></li>
            <li class="fragment">Specify <code>u</code> or <code>b</code> prefix for all string literals</li>
            <li class="fragment"><code>5/2 == 2</code> in Python 2 but <code>5/2 == 2.5</code> in Python 3</li>
            <li class="fragment">Some things don't exist in the same form (<code>cmp</code> function)</li>
            <li class="fragment">Running <code>pylint --py3k</code> will prints warnings about code that might be invalid in Python 3</li>
          </ul>
          <aside class="notes" data-markdown>
            - So a lot of the ambiguities that the automated conversion tools can't handle are due to this new distinction between text and bytes and the fact that Python 2 was really sloppy about requiring this distinction
            - Because Python 3 requires this distinction and Python 2 doesn't, you cannot unambiguously convert any Python 2 code into Python 3 code
            - Some unicode-related issues include **(click)**
              - Determining which StringIO alternative to use... io.StringIO or io.BytesIO
              - **(click)** The open() functionality changed.  Python 2 always gives you bytes back.  Python 3 gives you either text or bytes depending on what you ask for.
            - **(click)** You'll probably also want to add u and b prefixes to many your string literals to clarify whether they're unicode or bytes
            - There are some non-unicode issues you'll need to fix manually also...
            - For example division between integers changed in Python 3. **(click)**
            - And the automated tools fail on this because they don't know if your variables are integers or floating point numbers.
            - **(click)** And some things just don't really exist anymore in Python 3
            - **(click)** The pylint tool includes a `--py3k` flag that makes it so pylint doesn't print it's usual linting errors but instead prints out warnings about constructs that are invalid in Python 3
            - **[26 minutes]**

          </aside>
        </section>

      </section>

        <!-- 2 minutes -->
        <section>
          <h2>What about sudden migrations?</h2>
          <ul>
            <li class="fragment">Fork your Python 2 version and don't change it anymore</li>
            <li class="fragment">You shouldn't need a compatibility library</li>
            <li class="fragment">You could use <code>2to3</code> <span class="fragment">(I've never used it, good luck!)</span></li>
            <li class="fragment">You still need to manually fix all the same things (like unicode/bytes issues and division issues)</li>
            <li class="fragment">You still need a solid testing process</li>
          </ul>
          <aside class="notes" data-markdown>
            - TODO in theory, it's really not too different except that your code will be a little bit prettier immediately after this migration hopefully
          </aside>
        </section>

        <!-- 2 minutes -->
        <section>
          <h2>Python 2 to 3 Migration Cheat Sheet</h2>
          <ol>
            <li class="fragment">Use a guide to help you (<a href="https://portingguide.readthedocs.io">The Conservative Python 3 Porting Guide</a> or <a href="https://docs.python.org/3/howto/pyporting.html">the official porting guide</a>)</li>
            <li class="fragment">Make sure you have a testing process</li>
            <li class="fragment">Use an automated conversion tool (and a compatibility library) to help you</li>
            <li class="fragment">Figure out what you need to fix</li>
          </ul>
          <aside class="notes" data-markdown>
            - TODO
            - **[27 minutes]**
          </aside>
        </section>

      <!--
      <section>

        <section>
          <h2>Wait but...</h2>
          <ul>
          </ul>
          <aside class="notes" data-markdown>
            - TODO
          </aside>
        </section>

        <section>
          <h2>What about 2to3?</h2>
          <ul>
          </ul>
          <aside class="notes" data-markdown>
            - TODO
            - There is a tool built-in to Python that allows upgrading suddenly.  It's called 2to3. **(click)**
            - The official porting guide doesn't even mention 2to3 **(click)**
						- You can find resources that recommend 2to3, but most of them are older predate some of the tools that I'm going to be talking about. **(click)**
          </aside>
        </section>

        <section>
          <h2>future: is it a bad idea?</h2>
          <ul>
          </ul>
          <aside class="notes" data-markdown>
            - TODO is shimming code dangerous? (research this)
          </aside>
        </section>

      </section>
      -->

      <!-- 5 minutes -->
      <section>

        <section>
          <h2>We're not done yet</h2>
          <ul>
            <li class="fragment">Upgrading opens up so many new doors for you to open</li>
            <li class="fragment">Many features in Python 3 can be used in Python 2 already, but there are lots that cannot</li>
            <li class="fragment">Python 3 exclusive looks much nicer than "straddling code" that works in both 2 and 3.  I promise.</li>
            <li class="fragment">Python 3: brought to you by the makers of Python 2</li>
          </ul>
          <aside class="notes" data-markdown>
            - Upgrading to code that runs in Python 3 could be the end of your Python 3 porting journey **(click)**
            - But it could also be just the beginning **(click)**
            - There's about a decade's worth of Python 3-only features that you've been missing out on up to now. **(click)**
            - After you've upgraded, your code in going to look pretty ugly because it was meant to run in both Python 2 and Python 3 **(click)**
            - Once you've started removing the parts of your code that only exist for Python 2 compatibility and start embracing newer Python 3 features, you'll probably find that you actually *really* enjoy using Python 3.
          </aside>
        </section>

        <section>
          <h2>Big Python 3 syntax wins</h2>
          <ul>
            <li class="fragment">Type annotations!</li>
            <li class="fragment">The way more powerful <code>*</code> and <code>**</code> syntaxes</li>
            <li class="fragment">F-Strings!</li>
            <li class="fragment">Underscores in numeric literals: <code>1_000_000</code></li>
            <li class="fragment"><code>yield from</code> and <code>async</code> and <code>await</code></li>
            <li class="fragment">Dictionary key order is preserved</li>
            <li class="fragment">Lots more cool things in the standard library</li>
          </ul>
          <aside class="notes" data-markdown>
              - Python 3 not allows you to add type hints to your code. **(click)**  These are great for documentation and they're great for making sure your code is correct!
              - **(click)** You can more easily merge dictionaries merge dictionaries, you can unpack multiple dictionaries of `**kwargs` to functions, and all sorts of cool things with the packing and unpacking generalizations
              - You can also use the `*` for writing keyword-only arguments, which is super awkward in Python 2
              - **(click)** F-strings are like the format method in Python 2 except they're way less verbose
              - **(click)** You can use underscore in numeric literals as a thousands separator
              - **(click)** Lots of standard library things like functools.total_ordering and UserDict actually work
              - **(click)** Generators got some great syntactic additions.  There's yield from.  And the async and await syntax.
              - **(click)** Python 3.7 preserves the order of dictionaries, keyword arguments, and class attributes.  This is a really cool feature change.
          </aside>
        </section>

        <section>
          <h2>Changed Python 3 "Features"</h2>
          <ul>
            <li class="fragment">True division instead of floor division</li>
            <li class="fragment">The flexible print function</li>
            <li class="fragment">Strict ordering (strings cannot be compared to numbers)</li>
          </ul>
          <aside class="notes" data-markdown>
              - Sometimes it's hard to tell a bug from a feature
              - Python 3 removed or changed a lot of features to make them look less like bugs
              - Python 3 uses true division instead of floor division **(click)**
              - Python 3 doesn't have a print statement.  Instead there's a print function which is much more flexible. **(click)**
              - And Python 3 requires strict ordering of objects. **(click)**
              - In Python 2, loose ordering was a bug waiting to happen.
            - **[30 minutes]**
          </aside>
        </section>

      </section>

      <section style="text-align: left;" data-background="#663399" data-background-transition="slide" data-transition="slide">
        <h2>Need help getting your team <nobr>up to speed on Python?</nobr></h2>
        <h3>
          <strong>Trey Hunner</strong><br>
          <small>Python &amp; Django Team Trainer</small>
        </h3>
        <p>
          <small>
            Contact me: <a href="mailto:&#116;&#114;&#101;&#121;&#064;&#116;&#114;&#117;&#116;&#104;&#102;&#117;&#108;&#046;&#116;&#101;&#099;&#104;&#110;&#111;&#108;&#111;&#103;&#121;">&#116;&#114;&#101;&#121;&#064;&#116;&#114;&#117;&#116;&#104;&#102;&#117;&#108;&#046;&#116;&#101;&#099;&#104;&#110;&#111;&#108;&#111;&#103;&#121;</a>
          </small>
        </p>
        <p>
        <a href="http://truthful.technology"><img src="logo.svg" class="no-style logo"></a>
        <a href="http://pythonmorsels.com"><img src="python-morsels-logo.svg" class="no-style logo"></a>
        </p>
        <aside class="notes" data-markdown>
          - My name is Trey Hunner
          - I would love to teach Python and Django at your company
          - Feel free to shoot me an email
          - Thank you!
        </aside>
      </section>


      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script src="js/truthful.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>
